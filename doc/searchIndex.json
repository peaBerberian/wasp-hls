[{"file":"./Getting_Started/Welcome.html","index":[{"h2":"WaspHlsPlayer overview","body":"The WaspHlsPlayer is a media player library allowing to play HLS contents on the web efficiently by exploiting a WebWorker, allowing to run concurrently to the user interface and WebAssembly, allowing to do so in an optimized way. The WaspHlsPlayer requires both features to be available in environment it runs. It also support more advanced features, such as MSE-in-Workers on browsers that support them, though it can also run efficiently on environments without those. All of those features should ensure that an heavy UI won’t have a huge influence on media buffering, as well as ensuring that the media loading, parsing and buffering operations won’t be felt when interacting with the page.","anchorH2":"wasphlsplayer_overview"},{"h2":"Very quick start","body":"To let you quickly test the project, the WaspHlsPlayer provides embedded versions of its WebAssembly and Worker files, even if I recommend to store and serve those as separate files on production (more details in the rest of the documentation). You can thus very quickly test the WaspHlsPlayer by just installing it: // With npm npm install wasp-hls  // or with yarn yarn add wasp-hls  And then running the following JavaScript file. import WaspHlsPlayer from \"wasp-hls\"; import EmbeddedWasm from \"wasp-hls/wasm\"; import EmbeddedWorker from \"wasp-hls/worker\";  const player = new WaspHlsPlayer(videoElement); player   .initialize({     workerUrl: EmbeddedWorker,     wasmUrl: EmbeddedWasm,   })   .catch((err) => {     console.error(\"Could not initialize WaspHlsPlayer:\", err);   }); player.load(HLS_MULTIVARIANT_PLAYLIST_URL);  Where HLS_MULTIVARIANT_PLAYLIST_URL is the URL to the main playlist (called either the Multivariant Playlist or the Master Playlist) of your HLS content. Of course, once initialize has succeeded, you can play any HLS content you want on that WaspHlsPlayer instance.","anchorH2":"very_quick_start"},{"h2":"The documentation pages","body":"Those documentation pages are splitted into multiple categories:   You’re here in the “Getting Started” category which provides tutorials and other resources allowing to help you with basic usage of the WaspHlsPlayer.   You can also dive into the API, which specifies the behavior of everything that is possible with the WaspHlsPlayer.  ","anchorH2":"the_documentation_pages"}]},{"file":"./Getting_Started/Creating_a_WaspHlsPlayer.html","index":[{"h1":"Creating a new WaspHlsPlayer","body":"","anchorH1":"creating_a_new_wasphlsplayer"},{"h1":"Creating a new WaspHlsPlayer","h2":"Instantiation","body":"Each WaspHlsPlayer allows to play HLS content on a single video element. That video element has to be provided on instanciation like this: const player = new WaspHlsPlayer(videoElement);  More information on the WaspHlsPlayer’s constructor can be found in the API documentation page presenting the instantiation step. Note that the WaspHlsPlayer’s constructor optionally can take a second argument, which allows to overwrite its initial configuration. More information on this object is available in the API documentation. Before being ready to load contents on that new instance, we now have to “initialize” it, which is an operation described in the next chapter.","anchorH1":"creating_a_new_wasphlsplayer","anchorH2":"instantiation"},{"h1":"Creating a new WaspHlsPlayer","h2":"WaspHlsPlayer initialization","body":"Before it can actually load a content, the WaspHlsPlayer needs to let it have access to two files:   The worker file, which contains code which will run concurrently to your application.   The WebAssembly file, used by the worker file to run efficiently its internal logic.   Both of those files can be retrieved in the release page (you should choose the one linked to your actual WaspHlsPlayer’s version). They then have to be served via HTTP(S) (through a solution of your choosing), and can be communicated to the WaspHlsPlayer through its initialize method: player   .initialize({     workerUrl: \"https://www.example.com/worker.js\",     wasmUrl: \"https://www.example.com/wasp_hls_bg.wasm\",   })   .then(     () => {       console.log(\"WaspHlsPlayer initialized with success!\");     },     (err) => {       console.error(\"Could not initialize WaspHlsPlayer:\", err);     }   );  // we can now use the player (we don't need to await the Promise here)  Alternatively, if you don’t want the hassle of having to serve those files separately when developping, the WaspHlsPlayer also provide both the WebAssembly and Worker files through JavaScript-embedded versions, respectively through the \"wasp-hls/wasm\" and the \"wasp-hls/worker\" path: import EmbeddedWasm from \"wasp-hls/wasm\"; import EmbeddedWorker from \"wasp-hls/worker\";  player   .initialize({     workerUrl: EmbeddedWorker,     wasmUrl: EmbeddedWasm,   })   .then(     () => {       console.log(\"WaspHlsPlayer initialized with success!\");     },     (err) => {       console.error(\"Could not initialize WaspHlsPlayer:\", err);     }   );  // we can now use the player (we don't need to await the Promise here)  Note however that this leads to a huge file size (though which is drastically reduced when compressed) and to some small inefficencies on initialization (as those JavaScript files have to first be interpreted in the main thread), which is why I recommend serving both those files separately for production. It’s also possible to communicate an initial bandwidth estimate through the initialize method to improve the WaspHlsPlayer’s accuracy regarding its initially loaded quality. For more information on this “initialization” step, you can consult the API documentation page dedicated to it, here.","anchorH1":"creating_a_new_wasphlsplayer","anchorH2":"wasphlsplayer_initialization"}]},{"file":"./API/Overview.html","index":[{"h1":"WaspHlsPlayer API","body":"The API documentation is a thorough guide through every feature exposed by the WaspHlsPlayer, in a logical order. If you are very new to the WaspHlsPlayer and don’t want to dive deep in the API for the moment, you might want to check the Getting Started pages instead.  Only variables and methods defined here are considered as part of the API. Any other property or method you might find in any other way are not considered as part of the API and can thus change without notice. ","anchorH1":"wasphlsplayer_api"}]},{"file":"./API/Instantiation.html","index":[{"h1":"WaspHlsPlayer instantiation","body":"","anchorH1":"wasphlsplayer_instantiation"},{"h1":"WaspHlsPlayer instantiation","h2":"Description","body":"instantiating a WaspHlsPlayer is a necessary step before using most of its API, like load to load a new HLS content. It is here that the HTMLVideoElement (the <video /> HTML element) on which the content will play is given to the WaspHlsPlayer: import WaspHlsPlayer from \"wasp-hls\";  const videoElement = document.querySelector(\"video\"); const player = new WaspHlsPlayer(videoElement);  Note: For a more predictable behavior, it is best that you then use the WaspHlsPlayer’s API instead of any of the HTMLVideoElement’s own methods, attributes and events, excepted when the opposite is explicitely advised by this documentation (such as with [audio volume management](XXX TODO)). Optionally, you can give a second argument on instantiation, the WaspHlsPlayer’s original configuration object: const config = {   // Try to reach a buffer size of 20 seconds when playing   bufferGoal: 20,    // Re-do a segment request if it takes more than 10 seconds   segmentRequestTimeout: 10,    // ... }; const player = new WaspHlsPlayer(videoElement, config);  You may here only define a subset of those keys, in which case the WaspHlsPlayer will set sane default values for the others. You can also either not set it, set it to undefined or to an empty object, in which cases the WaspHlsPlayerConfig will use its inner default configuration instead. Note that this configuration object can be updated at any time through the [updateConfig](XXX TODO) method.","anchorH1":"wasphlsplayer_instantiation","anchorH2":"description"},{"h1":"WaspHlsPlayer instantiation","h2":"Syntax","body":"const player = new WaspHlsPlayer(videoElement);  // or, with a default configuration object const player = new WaspHlsPlayer(videoElement, configObject);    arguments:   videoElement HTMLVideoElement: The <video /> element on the page on which the content will play.   config (optional) Object|undefined: Default configuration object.    ","anchorH1":"wasphlsplayer_instantiation","anchorH2":"syntax"}]},{"file":"./API/Initialization.html","index":[{"h1":"WaspHlsPlayer Initialization","body":"","anchorH1":"wasphlsplayer_initialization"},{"h1":"WaspHlsPlayer Initialization","h2":"Description","body":"Once it has been Instantiated, the WaspHlsPlayer needs to be “initialized”. That initialization task is the step during which the two external parts of the WaspHlsPlayer, namely its worker file and WebAssembly file, are setup. Both of those files can be retrieved in in the release page, note that you should chose the files linked to the WaspHlsPlayer’s version used by your application. After recuperating both of those files, you need to host them, to then provide their URL to the WaspHlsPlayer’s initialize method: player   .initialize({     // URL to the worker file     workerUrl: \"https://www.example.com/worker.js\",      // URL to the WebAssembly file     wasmUrl: \"https://www.example.com/wasp_hls_bg.wasm\",      // Optional initial bandwidth estimate, in bits per seconds.     // Will be relied on before the `WaspHlsPlayer` is able to produce its own     // precize estimate.     // Can be unset or undefined to let the `WaspHlsPlayer` define its own,     // poor, initial value.     initialBandwidth: 200000,   })   .then(     () => {       console.log(\"WaspHlsPlayer initialized with success!\");     },     (err) => {       console.error(\"Could not initialize WaspHlsPlayer:\", err);     }   );  // we can now use the player (we don't need to await the Promise here) ","anchorH1":"wasphlsplayer_initialization","anchorH2":"description"},{"h1":"WaspHlsPlayer Initialization","h2":"Description","h3":"Preventing the need to serve those files separately","body":"Note that if you don’t want the supplementary step of serving both those files for now, the WaspHlsPlayer also provides embedded versions of both. With them, the code would be written as: import EmbeddedWasm from \"wasp-hls/wasm\"; import EmbeddedWorker from \"wasp-hls/worker\";  player   .initialize({     workerUrl: EmbeddedWorker,     wasmUrl: EmbeddedWasm,     initialBandwidth: 200000,   })   .then(     () => {       console.log(\"WaspHlsPlayer initialized with success!\");     },     (err) => {       console.error(\"Could not initialize WaspHlsPlayer:\", err);     }   );  // we can now use the player (we don't need to await the Promise here)  However I don’t recommend relying on embedded versions for production: Those versions lead to a huge file size (though which is drastically reduced when compressed) and to some small inefficencies on initialization (as those JavaScript files have to first be interpreted in the main thread).","anchorH1":"wasphlsplayer_initialization","anchorH2":"description","anchorH3":"preventing_the_need_to_serve_those_files_separately"},{"h1":"WaspHlsPlayer Initialization","h2":"Description","h3":"Be notified of when initialization succeeds (or fails)","body":"As you can see, the initialize method returns a promise, which is only resolved once the initialization process succeeded. That promise might also reject in the following situations:  The provided files could not be requested. An issue happened while trying to run and/or compile the given files  In those cases, the promise returned by initialize will reject. That promise might also reject if the player was disposed (through its dispose method) before initialization finished with success. Note that you don’t have to wait for that condition before using most of the WaspHlsPlayer’s methods, if you for example load a content with the load method before initialization succeeds, it will automatically be loaded once initialization is finished\". You can check the status of the initialization at any time by looking at the WaspHlsPlayer’s initializationStatus property: switch (player.initializationStatus) {   case \"Uninitialized\":     console.log(\"The WaspHlsPlayer has never been initialized.\");     break;    case \"Initializing\":     console.log(\"The WaspHlsPlayer is currently initializing.\");     break;    case \"Initialized\":     console.log(\"The WaspHlsPlayer has been initialized with success.\");     break;    case \"errored\":     console.log(\"The WaspHlsPlayer's initialization has failed.\");     break;    case \"disposed\":     console.log(\"The WaspHlsPlayer's instance has been disposed.\");     break; } ","anchorH1":"wasphlsplayer_initialization","anchorH2":"description","anchorH3":"be_notified_of_when_initialization_succeeds_(or_fails)"},{"h1":"WaspHlsPlayer Initialization","h2":"Description","h3":"Note for the hosting of the WebAssembly file","body":"It is generally recommended for performance reasons to serve WebAssembly files with the a Content-Type HTTP(S) response header set to application-wasm. Note however that this is not an obligation and that the actual performance impact is relatively small.","anchorH1":"wasphlsplayer_initialization","anchorH2":"description","anchorH3":"note_for_the_hosting_of_the_webassembly_file"}]},{"file":"./API/Loading_a_content.html","index":[{"h1":"Loading a content","body":"","anchorH1":"loading_a_content"},{"h1":"Loading a content","h2":"Description","body":"Loading a content through the WaspHlsPlayer can only be done once it has been instantiated and once initialize has been called (it is not necessary to await the returned Promise). This is the step where the URL of the Multivariant Playlist (before known as the “Master Playlist”) is provided to the WaspHlsPlayer, that takes care of media playback. That step is done through the load method, through a very straightforward call: // Here `MultivariantPlaylistUrl` is the HTTP(S) URL to the Multivariant // Playlist player.load(MultivariantPlaylistUrl);  You can then be notified of where the load operation is at (whether it is still loading the content, has loaded it or encountered an error) by either listening to the \"playerStateChange\" event or at any point in time by calling [the getPlayerState method](XXX TODO): player.addEventlistener(\"playerStateChange\", (playerState) => {   switch (playerState) {     case \"Loading\":       console.log(\"A new content is loading.\");       break;     case \"Loaded\":       console.log(\"The last loaded content is currently loaded.\");       break;     case \"Error\":       console.log(         \"The last loaded content cannot play anymore due to an error.\"       );       break;     case \"Stopped\":       console.log(\"No content is currently loaded nor loading.\");       break;   } });  Note that the WaspHlsPlayer doesn’t automatically begin playback once the content is loaded. To do so, you have to call the [resume](XXX TODO) method once the \"Loaded\" player state is reached: // Automatically play the content once it's loaded player.addEventlistener(\"playerStateChange\", (playerState) => {   if (playerState === \"Loaded\") {     player.resume();   } }); ","anchorH1":"loading_a_content","anchorH2":"description"},{"h1":"Loading a content","h2":"Options","body":"load also can take an optional second argument, an object representing its options. For now there’s only one optional property that can be set inside it, startingPosition.","anchorH1":"loading_a_content","anchorH2":"options"},{"h1":"Loading a content","h2":"Options","h3":"startingPosition","body":"type: number | object | undefined The startingPosition option allows to indicate a preferred position at which playback should begin. If not set or set to undefined, the WaspHlsPlayer will decide by itself where to begin in the content, based on content information. In most cases, this is what you want. As a number If you do want to start at a specific position, startingPosition can be set as a number, which will corresponds to the wanted starting position, in terms of content time (the position as deduced from the HLS Media Playlists, which may not be the same than the media time inside media segments) in seconds. For example, to begin playback of a VoD content at the second 10, you can write: player.load(playlistUrl, {   startingPosition: 10, });  Or to play some live contents at what was recorded one minute ago, you could write: // Unix timestamp, in seconds, corresponding to now minus 1 minute const date = Date.now() / 1000 - 60;  player.load(playlistUrl, {   startingPosition: date, });  As an object More complex relative wanted starting positions can be communicated by setting startingPosition to an object instead. Those objects each have two properties, startType, a string indicating the type of relative or absolute position, and position indicating the position value. A relative position to the initially minimum or maximum position can this way be given respectively by setting startType to \"FromBeginning\" and \"FromEnd\". For example, to start playback 10 seconds before the last initially available position (10 seconds before the end for a VoD content, or before live for a live content), you can write: player.load(playlistUrl, {   startingPosition: {     startType: \"FromEnd\",     position: 10,   }, });  If you however want to play 10 seconds after the first initially available position, you can write: player.load(playlistUrl, {   startingPosition: {     startType: \"FromBeginning\",     position: 10,   }, });  For completeness-sake, it’s also possible to communicate through an object an absolute position, exactly as if a number was directly communicated, you can do so through the \"Absolute\" startType. Thus to start at exactly the second 30, you can write: player.load(playlistUrl, {   startingPosition: {     startType: \"Absolute\",     position: 30,   }, }); ","anchorH1":"loading_a_content","anchorH2":"options","anchorH3":"%60startingposition%60"}]},{"file":"./API/Player_Events.html","index":[{"h1":"Player Events","body":"","anchorH1":"player_events"},{"h1":"Player Events","h2":"Overview","body":"As it begins to load a content, the WaspHlsPlayer will send various events allowing you:  to let you know the current playback conditions what audio tracks are available and which one is selected what variants (i.e. qualities) are available and which one is selected and so on  This page will document every one of them.","anchorH1":"player_events","anchorH2":"overview"},{"h1":"Player Events","h2":"Listening to an event","body":"The WaspHlsPlayer copies the same event listening API than the EventTarget you’re generally used to on the web. That is, you can use a method called addEventlistener to register a callback on an event and removeEventListener to remove it. For example, to add then immediately remove an event listener for the \"playerStateChange\" event, you can write: const onPlayerStateChange = (state) => {   console.log(\"new player state:\", state); }; player.addEventListener(\"playerStateChange\", onPlayerStateChange); player.removeEventListener(\"playerStateChange\", onPlayerStateChange); ","anchorH1":"player_events","anchorH2":"listening_to_an_event"},{"h1":"Player Events","h2":"Event: playerStateChange","body":"The \"playerStateChange\" event is sent when the “state” of playback is updpated, with a string describing that new state as a payload. This is the event you want to listen to to be alerted when your loaded content can start to play, or when it was actually stopped. The various values that this state can be set to are:   \"Stopped\": The content has just been stopped. No content is playing anymore.   \"Loading\": Set synchronously when the load method is called, to indicate that a new content is being loaded.   \"Loaded\": the last content loaded with load is now ready to play.   \"Error\": the last content loaded with load has been interrupted due to an error. An \"error\" event should also have been triggered. You can also know which error happened by calling the [getError](XXX TODO) method.   As such, for example to automatically play when the content is loaded, you can combine this event with a call to [resume](XXX TODO), by writing: player.addEventListener(\"playerStateChange\", (state) => {   if (state === \"Loaded\") {     // auto-play when loaded     player.resume();   } });  You can also know the player’s state at any time by calling the [getPlayerState](XXX TODO) method.","anchorH1":"player_events","anchorH2":"event:_%60playerstatechange%60"},{"h1":"Player Events","h2":"Event: paused","body":"The \"paused\" event is sent when a loaded content (which is a content which currently is in the [\"Loaded\" state](XXX TODO) was just paused, generally due to a previous call to the [pause method](XXX TOOD). This event doesn’t have a payload. Example of usage: player.addEventListener(\"paused\", () => {   console.log(\"Playback is now effectively paused.\"); });  You can also know whether playback is currently paused at any time by calling the [isPaused](XXX TODO) method.","anchorH1":"player_events","anchorH2":"event:_%60paused%60"},{"h1":"Player Events","h2":"Event: playing","body":"The \"playing\" event is sent when a loaded content (which is a content which currently is in the [\"Loaded\" state](XXX TODO) went out of a “paused” status, generally due to a previous call to the [resume method](XXX TOOD). XXX TODO what about when ended then calling play? To check This event doesn’t have a payload. Example of usage: player.addEventListener(\"playing\", () => {   console.log(\"Playback is now effectively playing.\"); });  You can also know whether playback is currently playing at any time by calling the [isPlaying](XXX TODO) method.","anchorH1":"player_events","anchorH2":"event:_%60playing%60"},{"h1":"Player Events","h2":"Event: ended","body":"The \"ended\" event is sent when playback reached the end of the content. Playback is now paused, generally at the last video frame visible of the content. XXX TODO is the “paused” event also sent? To check. This event doesn’t have a payload. Example of usage: player.addEventListener(\"ended\", () => {   console.log(\"Playback is now ended.\"); });  You can also know whether the end is currently reached at any time by calling the [isEnded](XXX TODO) method.","anchorH1":"player_events","anchorH2":"event:_%60ended%60"},{"h1":"Player Events","h2":"Event: error","body":"The \"error\" event is sent when an error interrupted playback of the last content. The corresponding Error object is sent as a payload. For more information on the potential errors see the [Errors and warnings page](XXX TODO). Example of a callback registered to that event: player.addEventListener(\"error\", (error) => {   console.error(\"An error just stopped playback:\", error); });  Just before the \"error\" event is sent, the player’s start (as returned by the [getPlayerState](XXX TODO) method and emitted by the playerStateChange event are set to \"Error\". Also, the [getError](XXX TODO) method should now return the same error object than the one emitted as a payload of the error event, until another content is loaded or until [stop](XXX TODO) is called, whichever comes first.","anchorH1":"player_events","anchorH2":"event:_%60error%60"},{"h1":"Player Events","h2":"Event: warning","body":"The \"warning\" event is sent when a minor error happened, though unlike the error event, it hasn’t resulted in playback interruption. The corresponding Error object is sent as a payload. For more information on the potential errors see the [Errors and warnings page](XXX TODO). Example of a callback registered to that event: player.addEventListener(\"warning\", (error) => {   console.warn(\"A minor error just happened:\", error); }); ","anchorH1":"player_events","anchorH2":"event:_%60warning%60"},{"h1":"Player Events","h2":"Event: rebufferingStarted","body":"The \"rebufferingStarted\" event is sent when a loaded content (which is a content which currently is in the [\"Loaded\" state](XXX TODO) just began rebuffering. Rebuffering is a period during which playback is paused to build back buffer, in that condition, playback will only restart (by itself) once enough buffer is loaded. Rebuffering can for example happen if the network bandwidth is currently too low to play sustainably the current content or due to some other event like a [seek](XXX TODO). Note that rebuffering can also happen when playback is paused. It just means that there’s not enough media data to begin playback. This event doesn’t have a payload. Example of usage: player.addEventListener(\"rebufferingStarted\", () => {   console.log(\"Playback is now paused due to a started rebuffering period\"); });  You can also know whether playback is currently rebuffering at any time by calling the [isRebuffering](XXX TODO) method.","anchorH1":"player_events","anchorH2":"event:_%60rebufferingstarted%60"},{"h1":"Player Events","h2":"Event: rebufferingEnded","body":"The \"rebufferingEnded\" event is sent when a loaded content (which is a content which currently is in the [\"Loaded\" state](XXX TODO) just exited a rebuffering period. You should have previously received a \"rebufferingStarted\" event when that rebuffering period had started. Rebuffering is a period during which playback is paused to build back buffer, in that condition, playback will only restart (by itself) once enough buffer is loaded. Rebuffering can for example happen if the network bandwidth is currently too low to play sustainably the current content or due to some other event like a [seek](XXX TODO). Note that rebuffering can also happen when playback is paused. It just means that there’s not enough media data to begin playback. This event doesn’t have a payload. Example of usage: player.addEventListener(\"rebufferingEnded\", () => {   console.log(\"Playback can now restart as we're exited a rebuffering period.\"); });  You can also know whether playback is currently rebuffering at any time by calling the [isRebuffering](XXX TODO) method.","anchorH1":"player_events","anchorH2":"event:_%60rebufferingended%60"},{"h1":"Player Events","h2":"Event: variantUpdate","body":"The \"variantUpdate event is sent when the currently-loaded variant, which basically represents the video and audio qualities, has changed. Note that the variantUpdate is only about the variant being loaded, which may be different than the one being currently played (you’re generally playing already-loaded content). The payload of that event contains the information available on that variant if known, or undefined if the characteristics of the variant is unknown. When set to an object, it should contain the following keys:   id (number): The identifier for that variant. Might be useful for example when wanting to lock that variant in place through the [lockVariant](XXX TODO) method.   width (number | undefined): The optimal width at which the video media data linked to that variant is displayed, in pixel. undefined if unknown or if there’s no video data.   height (number | undefined): The optimal height at which the video media data linked to that variant is displayed, in pixel. undefined if unknown or if there’s no video data.   frameRate (number | undefined): The maximum frame for the video media data linked to that variant. undefined if unknown or if there’s no video data.   bandwidth (number | undefined): The peak segment bit rate of any media combination in that variant, in bits per second. undefined if unknown,   You can also know at any time the same characteristics of the current variant by calling the [getCurrentVariant](XXX TODO) method.","anchorH1":"player_events","anchorH2":"event:_%60variantupdate%60"},{"h1":"Player Events","h2":"Event: variantLockUpdate","body":"The \"variantLockUpdate event is sent when the current variant has been “locked” or unlocked. A variant lock is the result of calling the [lockVariant](XXX TODO) method, which allows to force a given variant (e.g. manually forcing 1080p video content). When a single variant is forced, we say that it is “locked”, when the WaspHlsPlayer actually chooses its variant amongst the pool of currenly-available ones, we say that it is “unlocked”. This variant may be locked due to various events. For example due to a [unlockVariant](XXX TODO) call or due to a change of track (e.g. through the [setAudioTrack](XXX TODO) method) incompatible with the locked variant. When the variant is actually “unlocked”, the payload of that event will be null. When the variant is now “locked”, it is set to an object representing that variant’s characteristics. That object will have the following keys (same than for the variantUpdate event):   id (number): The identifier for that variant. Might be useful for example when wanting to lock that variant in place through the [lockVariant](XXX TODO) method.   width (number | undefined): The optimal width at which the video media data linked to that variant is displayed, in pixel. undefined if unknown or if there’s no video data.   height (number | undefined): The optimal height at which the video media data linked to that variant is displayed, in pixel. undefined if unknown or if there’s no video data.   frameRate (number | undefined): The maximum frame for the video media data linked to that variant. undefined if unknown or if there’s no video data.   bandwidth (number | undefined): The peak segment bit rate of any media combination in that variant, in bits per second. undefined if unknown,   If that change of lock status led to a change of currently-loaded variant, you’ll also receive a variantUpdate event. You can know at any time whether a variant is currently locked and which one from the [getLockedVariant](XXX TODO) method.","anchorH1":"player_events","anchorH2":"event:_%60variantlockupdate%60"},{"h1":"Player Events","h2":"Event: variantListUpdate","body":"The \"variantListUpdate event is sent when the list of available variants, which basically represent the video and audio qualities, has changed. The payload of that event contains an array object, each object containing the information available for a particular variant. Each object should contain the following keys (same than for the variantUpdate event):   id (number): The identifier for that variant. Might be useful for example when wanting to lock that variant in place through the [lockVariant](XXX TODO) method.   width (number | undefined): The optimal width at which the video media data linked to that variant is displayed, in pixel. undefined if unknown or if there’s no video data.   height (number | undefined): The optimal height at which the video media data linked to that variant is displayed, in pixel. undefined if unknown or if there’s no video data.   frameRate (number | undefined): The maximum frame for the video media data linked to that variant. undefined if unknown or if there’s no video data.   bandwidth (number | undefined): The peak segment bit rate of any media combination in that variant, in bits per second. undefined if unknown,   You can also know at any time the list of available variants by calling the [getVariantList](XXX TODO) method.","anchorH1":"player_events","anchorH2":"event:_%60variantlistupdate%60"},{"h1":"Player Events","h2":"Event: audioTrackUpdate","body":"The \"audioTrackUpdate event is sent when the currently-loaded audio track has changed. Note that what we call “audio track” here may actually be a set of multiple audio qualities (generally dispatched in various variants) all with the same characteristics (same language, same name, same accessibility, same number of channels etc.). The payload of that event contains the information available on that audio track if known, or undefined either if the characteristics of the audio track is unknown or if no audio track is active. When set to an object, it should contain the following keys:   id (number): The identifier for that audio track. It is generally useful to for example set the audio track though a [setAudioTrack](XXX TODO) call.   language (string | undefined): The primary language used in this audio track, as a language tag. undefined if unknown or if there’s no language involved.   assocLanguage (string | undefined): A secondary language associated to the audio track, as a language tag. Such language is often used in a different role than the language specified through the language property (e.g., written versus spoken, or a fallback dialect). undefined if unknown or if there’s no language involved.   name (string): Human-readable description of the audio track. If the language property is set, it should generally be in that language.   channels (number | undefined): If set, it is the count of audio channels, indicating the maximum number of independent and simultaneous audio channels present in any media data in that audio track. For example, an AC-3 5.1 Rendition would have a CHANNELS=“6” attribute.   You can also know at any time the same characteristics of the current audio track by calling the [getCurrentAudioTrack](XXX TODO) method.","anchorH1":"player_events","anchorH2":"event:_%60audiotrackupdate%60"},{"h1":"Player Events","h2":"Event: audioTrackListUpdate","body":"The \"audioTrackListUpdate event is sent when the list of available audio tracks has changed. The payload of that event contains an array object, each object containing the information available for a particular audio track. Each object should contain the following keys (same than for the audioTrackUpdate event):   id (number): The identifier for that audio track. It is generally useful to for example set the audio track though a [setAudioTrack](XXX TODO) call.   language (string | undefined): The primary language used in this audio track, as a language tag. undefined if unknown or if there’s no language involved.   assocLanguage (string | undefined): A secondary language associated to the audio track, as a language tag. Such language is often used in a different role than the language specified through the language property (e.g., written versus spoken, or a fallback dialect). undefined if unknown or if there’s no language involved.   name (string): Human-readable description of the audio track. If the language property is set, it should generally be in that language.   channels (number | undefined): If set, it is the count of audio channels, indicating the maximum number of independent and simultaneous audio channels present in any media data in that audio track. For example, an AC-3 5.1 Rendition would have a CHANNELS=“6” attribute.   You can also know at any time the list of available audio tracks by calling the [getAudioTrackList](xxx todo) method.","anchorH1":"player_events","anchorH2":"event:_%60audiotracklistupdate%60"}]},{"file":"./API/Configuration_Object.html","index":[{"h1":"Player Configuration","body":"","anchorH1":"player_configuration"},{"h1":"Player Configuration","h2":"Overview","body":"On WaspHlsPlayer instantiation, a configuration object is created and associated to this instance. It allows to configure many aspects of the player, from how much buffer you would prefer to build to how many request retry should be performed if some fails, and any of it can be updated at any time, even when a content impacted by it is playing. An initial config can optionally be given on instantiation (as indicated in the corresponding API documentation page). If not set, a sane default configuration will be generated instead by the WaspHlsPlayer. Any property of that configuration may also be updated at any time through the [updateConfig](XXX TODO) call. For example, to update the bufferGoal property to 20 seconds, you can write: player.updateConfig({   bufferGoal: 20, });  Note that because most of that configuration’s values are actually relied on by code running in a worker, there’s a necessary delay before it actually becomes considered (it doesn’t happen synchronously). The last version of that configuration can also be recuperated through the [getConfig](XXX TODO) method. The rest of this page is going to focus on each properties declared on this configuration object.","anchorH1":"player_configuration","anchorH2":"overview"},{"h1":"Player Configuration","h2":"bufferGoal","body":"type: number Amount of buffer, in seconds, to “build” ahead of the currently wated position. Once that amount is reached, we’ll stop loading new data until we go under again. A lower value will mean less memory and network resources are generally taken, but more risk of rebuffering. A higher value will mean the opposite. A value in the 15-50 range is generally safe.","anchorH1":"player_configuration","anchorH2":"%60buffergoal%60"},{"h1":"Player Configuration","h2":"segmentMaxRetry","body":"type: number Amount of times a failed segment request might be retried on errors that seem temporary (such as an HTTP 404 for example):  1 meaning it will be retried once 2 twice 0 never retried etc.  To set to -1 for infinite retry. Do not be scared to put a high value if you would prefer to retry over stopping on error. There’s an “exponential backoff” mechanism whose main objective is to avoid overloading servers and network resources. So retry never will happen in a quick loop.","anchorH1":"player_configuration","anchorH2":"%60segmentmaxretry%60"},{"h1":"Player Configuration","h2":"segmentRequestTimeout","body":"type: number Number of milliseconds after which a segment request with no response will be automatically cancelled due to a “timeout”. Depending on the configuration, the segment request might then be retried. To set to -1 for disabling segment request timeouts.","anchorH1":"player_configuration","anchorH2":"%60segmentrequesttimeout%60"},{"h1":"Player Configuration","h2":"segmentBackoffBase","body":"type: number If a segment request has to be retried, we will wait an amount of time before restarting the request. That delay raises if the same segment request fails multiple consecutive times, starting from around this value in milliseconds to segmentBackoffMax milliseconds. The step at which it raises is not configurable here, but can be resumed as a power of 2 raise on the previous value each time.","anchorH1":"player_configuration","anchorH2":"%60segmentbackoffbase%60"},{"h1":"Player Configuration","h2":"segmentBackoffMax","body":"type: number If a segment request has to be retried, we will wait an amount of time before restarting the request. That delay raises if the same segment request fails multiple consecutive times, starting from around segmentBackoffBase milliseconds to this value in milliseconds. The step at which it raises is not configurable here, but can be resumed as a power of 2 raise on the previous value each time.","anchorH1":"player_configuration","anchorH2":"%60segmentbackoffmax%60"},{"h1":"Player Configuration","h2":"multiVariantPlaylistMaxRetry","body":"type: number Amount of times a failed Multivariant Playlist request might be retried on errors that seem temporary (such as an HTTP 404 for example):  1 meaning it will be retried once 2 twice 0 never retried etc.  To set to -1 for infinite retry. Do not be scared to put a high value if you would prefer to retry over stopping on error. There’s an “exponential backoff” mechanism whose main objective is to avoid overloading servers and network resources. So retry never will happen in a quick loop.","anchorH1":"player_configuration","anchorH2":"%60multivariantplaylistmaxretry%60"},{"h1":"Player Configuration","h2":"multiVariantPlaylistRequestTimeout","body":"type: number Number of milliseconds after which a Multivariant Playlist request with no response will be automatically cancelled due to a “timeout”. Depending on the configuration, the Multivariant Playlist request might then be retried. To set to -1 for disabling Multivariant Playlist request timeouts.","anchorH1":"player_configuration","anchorH2":"%60multivariantplaylistrequesttimeout%60"},{"h1":"Player Configuration","h2":"multiVariantPlaylistBackoffBase","body":"type: number If a Multivariant Playlist request has to be retried, we will wait an amount of time before restarting the request. That delay raises if the same request fails multiple consecutive times, starting from around this value in milliseconds to multiVariantPlaylistBackoffMax milliseconds. The step at which it raises is not configurable here, but can be resumed as a power of 2 raise on the previous value each time.","anchorH1":"player_configuration","anchorH2":"%60multivariantplaylistbackoffbase%60"},{"h1":"Player Configuration","h2":"multiVariantPlaylistBackoffMax","body":"type: number If a Multivariant Playlist request has to be retried, we will wait an amount of time before restarting the request. That delay raises if the same request fails multiple consecutive times, starting from around multiVariantPlaylistBackoffBase milliseconds to this value in milliseconds. The step at which it raises is not configurable here, but can be resumed as a power of 2 raise on the previous value each time.","anchorH1":"player_configuration","anchorH2":"%60multivariantplaylistbackoffmax%60"},{"h1":"Player Configuration","h2":"mediaPlaylistMaxRetry","body":"type: number Amount of times a failed Media Playlist request might be retried on errors that seem temporary (such as an HTTP 404 for example):  1 meaning it will be retried once 2 twice 0 never retried etc.  To set to -1 for infinite retry. Do not be scared to put a high value if you would prefer to retry over stopping on error. There’s an “exponential backoff” mechanism whose main objective is to avoid overloading servers and network resources. So retry never will happen in a quick loop.","anchorH1":"player_configuration","anchorH2":"%60mediaplaylistmaxretry%60"},{"h1":"Player Configuration","h2":"mediaPlaylistRequestTimeout","body":"type: number Number of milliseconds after which a Media Playlist request with no response will be automatically cancelled due to a “timeout”. Depending on the configuration, the Media Playlist request might then be retried. To set to -1 for disabling Media Playlist request timeouts.","anchorH1":"player_configuration","anchorH2":"%60mediaplaylistrequesttimeout%60"},{"h1":"Player Configuration","h2":"mediaPlaylistBackoffBase","body":"type: number If a Media Playlist request has to be retried, we will wait an amount of time before restarting the request. That delay raises if the same request fails multiple consecutive times, starting from around this value in milliseconds to mediaPlaylistBackoffMax milliseconds. The step at which it raises is not configurable here, but can be resumed as a power of 2 raise on the previous value each time.","anchorH1":"player_configuration","anchorH2":"%60mediaplaylistbackoffbase%60"},{"h1":"Player Configuration","h2":"mediaPlaylistBackoffMax","body":"type: number If a Media Playlist request has to be retried, we will wait an amount of time before restarting the request. That delay raises if the same request fails multiple consecutive times, starting from around mediaPlaylistBackoffBase milliseconds to this value in milliseconds. The step at which it raises is not configurable here, but can be resumed as a power of 2 raise on the previous value each time.","anchorH1":"player_configuration","anchorH2":"%60mediaplaylistbackoffmax%60"}]},{"file":"./API/Player_Errors.html","index":[{"h1":"Player Errors","body":"","anchorH1":"player_errors"},{"h1":"Player Errors","h2":"Overview","body":"Player errors are Error objects which are sent an issue linked to the playback of the last-loaded content arised. All errors in the WaspHlsPlayer follow a common format, with a name, message, code and globalCode property. Some more specific errors have more descriptive properties. All of those are defined in this documentation page.","anchorH1":"player_errors","anchorH2":"overview"},{"h1":"Player Errors","h2":"Fatal errors and warnings","body":"There is two distincts types of errors:   “Fatal” errors, which are major errors led to playback interruption. Such errors are sent through a \"error\" event and are then returned by the getError method once the \"error\" event has been triggered for the current content.   warnings, which are minor errors, sent through the \"warning\" event.   Thus you can know if you received a fatal error (which thus interrupted playback) or a warning (for which the WaspHlsPlayer is capable of staying resilient to) based on the event and/or API which sent it.","anchorH1":"player_errors","anchorH2":"fatal_errors_and_warnings"},{"h1":"Player Errors","h2":"Common structure of a WaspHlsPlayer’s error","body":"All fatal errors and warnings follow the same structure. They extend the JavaScript Error Object and add multiple properties giving more indication over the issue encountered. All the following properties are common to all errors (sent through \"warning\" and \"error\" events, as well as returned by the getError method):   name (string): The type of error received. The name property allows you to detect XXX TDOO   message (string): A human-readable description of the Error, This message property might change from version to version.   code (string): An error code identifying the exact error encountered. Unlike message, the code property is intented to be stable and as such may be used programatically for error detection. The code should be sufficient to identify a particular error in your application. The name property only allowing to identify the particular type of Error instance you’re currently handling if you want to check the error Object’s properties. More details on that below.   globalCode (string): Contains the exact same value as the code property. We provide both for technical TypeScript-related reasons. globalCode is typed as an union of all potential code strings that may be returned by the WaspHlsPlayer in general, whereas code is typed as an union of code strings that may be linked to error with the same name. Both are correct in terms of type-checking, code being typed as a still valid sub-set of the globalCode property. The main difference will be when you rely on TypeScript to handle that error: In code handling all error objects without first checking the name property, TypeScript will give better autocompletion results when using globalCode. However if you filtered by name in your code, then code will be the most precize one.  ","anchorH1":"player_errors","anchorH2":"common_structure_of_a_%60wasphlsplayer%60's_error"},{"h1":"Player Errors","h2":"Error type: WaspMultivariantPlaylistRequestError","body":"WaspMultivariantPlaylistRequestError are errors triggered when an error arised while doing the Multivariant Playlist HTTP(S) request. Its name property is set to \"WaspMultivariantPlaylistRequestError\". For example to catch when a fatal error was due to a failure to request the Multivariant Playlist, you can write: player.addEventlistener(\"error\", (error) => {   if (error.name === \"WaspMultivariantPlaylistRequestError\") {     // This error was due to a request failure of the Multivariant Playlist\");   } });  WaspMultivariantPlaylistRequestError also may have the following property:   status (number|undefined: The failed request’s HTTP(S) response status. undefined if unknown, not checked or if not yet received (e.g. in case of a timeout).  ","anchorH1":"player_errors","anchorH2":"error_type:_%60waspmultivariantplaylistrequesterror%60"},{"h1":"Player Errors","h2":"Error type: WaspMultivariantPlaylistRequestError","h3":"Error codes","body":"A WaspMultivariantPlaylistRequestError’s code property can be set to any of the following values:   \"MultivariantPlaylistBadHttpStatus\": The HTTP(s) status on the response indicated that the Multivariant Playlist could not be fetched.   \"MultivariantPlaylistRequestTimeout\": The HTTP(s) request for the Multivariant Playlist timeouted according to the current configuration.   \"MultivariantPlaylistRequestError\": The HTTP(s) request itself failed to be performed (might be because we’re offline, might be because of security policies etc.) for the Multivariant Playlist.   \"MultivariantPlaylistRequestOtherError\": The HTTP(s) request itself failed to be performed for another, unknown, reason for the Multivariant Playlist.  ","anchorH1":"player_errors","anchorH2":"error_type:_%60waspmultivariantplaylistrequesterror%60","anchorH3":"error_codes"},{"h1":"Player Errors","h2":"Error type: WaspMultivariantPlaylistParsingError","body":"","anchorH1":"player_errors","anchorH2":"error_type:_%60waspmultivariantplaylistparsingerror%60"},{"h1":"Player Errors","h2":"Error type: WaspMediaPlaylistRequestError","body":"WaspMediaPlaylistRequestError are errors triggered when an error arised while doing a Media Playlist HTTP(S) request. Its name property is set to \"WaspMediaPlaylistRequestError\". For example to catch when a fatal error was due to a failure to request a Media Playlist, you can write: player.addEventlistener(\"error\", (error) => {   if (error.name === \"WaspMediaPlaylistRequestError\") {     // This error was due to a request failure of a Media Playlist\");   } });  WaspMediaPlaylistRequestError also may have the following property:   status (number|undefined: The failed request’s HTTP(S) response status. undefined if unknown, not checked or if not yet received (e.g. in case of a timeout).   mediaType (string): The “media type” associated to that Media Playlist. Examples of media types are \"Audio\" for a Media Playlist linked to resources containing just audio media content, and \"Video\" for a Media Playlist which contains video content (it may be only video, video with audio, with captions etc.).  ","anchorH1":"player_errors","anchorH2":"error_type:_%60waspmediaplaylistrequesterror%60"},{"h1":"Player Errors","h2":"Error type: WaspMediaPlaylistRequestError","h3":"Error codes","body":"A WaspMediaPlaylistRequestError’s code property can be set to any of the following values:   \"MediaPlaylistBadHttpStatus\": The HTTP(s) status on the response indicated that the Media Playlist could not be fetched.   \"MediaPlaylistRequestTimeout\": The HTTP(s) request for the Media Playlist timeouted according to the current configuration.   \"MediaPlaylistRequestError\": The HTTP(s) request itself failed to be performed (might be because we’re offline, might be because of security policies etc.) for the Media Playlist.   \"MediaPlaylistRequestOtherError\": The HTTP(s) request itself failed to be performed for another, unknown, reason for the Media Playlist.  ","anchorH1":"player_errors","anchorH2":"error_type:_%60waspmediaplaylistrequesterror%60","anchorH3":"error_codes_(1)"},{"h1":"Player Errors","h2":"Error type: WaspMediaPlaylistParsingError","body":"","anchorH1":"player_errors","anchorH2":"error_type:_%60waspmediaplaylistparsingerror%60"},{"h1":"Player Errors","h2":"Error type: WaspSegmentRequestError","body":"WaspSegmentRequestError are errors triggered when an error arised while doing a segment HTTP(S) request. Its name property is set to \"WaspSegmentRequestError\". For example to catch when a fatal error was due to a failure to request a segment, you can write: player.addEventlistener(\"error\", (error) => {   if (error.name === \"WaspSegmentRequestError\") {     // This error was due to a request failure of a segment\");   } });  WaspSegmentRequestError also may have the following property:   isInit (boolean|undefined): If true, the error concerns an initialization segment (a segment without media data, intented for lower-level media decoders initialization). If false, it concerns a media segment (a segment with media data). If undefined it is not known whether it concerns an initialization or media segment.  ","anchorH1":"player_errors","anchorH2":"error_type:_%60waspsegmentrequesterror%60"},{"h1":"Player Errors","h2":"Error type: WaspSegmentRequestError","h3":"Error codes","body":"A WaspSegmentRequestError’s code property can be set to any of the following values:   \"SegmentBadHttpStatus\": The HTTP(s) status on the response indicated that the segment could not be fetched.   \"SegmentRequestTimeout\": The HTTP(s) request for the segment timeouted according to the current configuration.   \"SegmentRequestError\": The HTTP(s) request itself failed to be performed (might be because we’re offline, might be because of security policies etc.) for the Media Playlist.   \"SegmentRequestOtherError\": The HTTP(s) request itself failed to be performed for another, unknown, reason for the segment.  ","anchorH1":"player_errors","anchorH2":"error_type:_%60waspsegmentrequesterror%60","anchorH3":"error_codes_(2)"},{"h1":"Player Errors","h2":"Error type: WaspSegmentParsingError","body":"","anchorH1":"player_errors","anchorH2":"error_type:_%60waspsegmentparsingerror%60"},{"h1":"Player Errors","h2":"Error type: WaspSourceBufferCreationError","body":"","anchorH1":"player_errors","anchorH2":"error_type:_%60waspsourcebuffercreationerror%60"},{"h1":"Player Errors","h2":"Error type: WaspSourceBufferError","body":"","anchorH1":"player_errors","anchorH2":"error_type:_%60waspsourcebuffererror%60"},{"h1":"Player Errors","h2":"Error type: WaspOtherError","body":"XXX TODO","anchorH1":"player_errors","anchorH2":"error_type:_%60waspothererror%60"}]},{"file":"./API/Basic_Methods/initialize.html","index":[{"h1":"initialize method","body":"","anchorH1":"%60initialize%60_method"},{"h1":"initialize method","h2":"Description","body":"Initialize the WaspHlsPlayer, see the API documentation page on initialization for more information.","anchorH1":"%60initialize%60_method","anchorH2":"description"},{"h1":"initialize method","h2":"Syntax","body":"// Without an initial bandwidth setup: const initializationPromise = player.initialize({   workerUrl,   wasmUrl, });  // With an initial bandwidth, generally to start playing with an appropriate // quality directly: const initializationPromise = player.initialize({   workerUrl,   wasmUrl,   initialBandwidth, });    arguments:   initObject Object: The properties required for initialization. This object should have the following properties present:   workerUrl (string): URL to the Worker file, that you have hosted.   wasmUrl (string): URL to the WebAssembly file, that you have hosted.   It has one additional optional property:  initialBandwidth (number|undefined): An initial bandwidth estimate, in bits per second, which will be relied on initially when starting to load the first content. If undefined or not set, the WaspHlsPlayer will define its own initial bandwidth, generally of a poor quality (but will be able to provide a better estimate soon enough).      return value:   Promise: Promise resolving when and if the initialization step finished with success. That Promise may also reject in case any of its step failed (such as the fetching of the required resources), in which case the WaspHlsPlayer won’t be able to be used.","anchorH1":"%60initialize%60_method","anchorH2":"syntax"}]},{"file":"./API/Basic_Methods/load.html","index":[{"h1":"load method","body":"","anchorH1":"%60load%60_method"},{"h1":"load method","h2":"Description","body":"Load a content see the API documentation page on loading a content for more information.","anchorH1":"%60load%60_method","anchorH2":"description"},{"h1":"load method","h2":"Syntax","body":"// Without options player.load(url);  // With options player.load(url, {   startingPosition: initialWantedPosition, });    arguments:   url string: Url to the Multivariant Playlist of the content you want to play.   options Object: Optional argument to configure how the content will be loaded. Can contain the following keys:  startType (number|object|undefined): indicate a preferred starting position. See the documentation page on loading a content for more information     ","anchorH1":"%60load%60_method","anchorH2":"syntax"}]},{"file":"./API/Basic_Methods/updateConfig.html","index":[{"h1":"updateConfig method","body":"","anchorH1":"%60updateconfig%60_method"},{"h1":"updateConfig method","h2":"Description","body":"Update some or all of the Configuration Object properties. That method accepts an object which can be a redefinition of the whole configuration object or only a subset by only declaring some of its properties. For example, to only set the segmentMaxRetry configuration to 3, you can write: player.updateConfig({   segmentMaxRetry: 3, });  Note that to ignore some properties, you can also set them to undefined. As such, the following code will also JUST update the segmentMaxRetry configuration to 3. player.updateConfig({   bufferGoal: undefined,   segmentMaxRetry: 3, });  This is possible because no properties of the Configuration Object has undefined as a valid value. Also note that because most of that configuration’s values are actually relied on by code running in a worker, there’s a necessary delay before it actually becomes considered (it doesn’t happen synchronously).","anchorH1":"%60updateconfig%60_method","anchorH2":"description"},{"h1":"updateConfig method","h2":"Syntax","body":"player.updateConfig(configUpdate);    argument:  configUpdate Object: Updates to combine with the previous configuration object. All properties unset or set to undefined will be let as they were before.   ","anchorH1":"%60updateconfig%60_method","anchorH2":"syntax"}]},{"file":"./API/Basic_Methods/getConfig.html","index":[{"h1":"getConfig method","body":"","anchorH1":"%60getconfig%60_method"},{"h1":"getConfig method","h2":"Description","body":"Obtain the last set Configuration Object as a whole.","anchorH1":"%60getconfig%60_method","anchorH2":"description"},{"h1":"getConfig method","h2":"Syntax","body":"const config = player.getConfig();   return value:  Object: Returns the current Configuration Object, taking into consideration all potential updates you’ve done to it since.","anchorH1":"%60getconfig%60_method","anchorH2":"syntax"}]},{"file":"./API/Basic_Methods/getPlayerState.html","index":[{"h1":"getPlayerState method","body":"XXX TODO","anchorH1":"%60getplayerstate%60_method"}]},{"file":"./API/Basic_Methods/pause.html","index":[{"h1":"pause method","body":"","anchorH1":"%60pause%60_method"},{"h1":"pause method","h2":"Description","body":"Pause the currently-loaded content. Equivalent to a video element’s pause method. pause can only be called when the WaspHlsPlayer instance is [in the \"Loaded\"](XXX TODO) state.","anchorH1":"%60pause%60_method","anchorH2":"description"},{"h1":"pause method","h2":"Syntax","body":"player.pause(); ","anchorH1":"%60pause%60_method","anchorH2":"syntax"}]},{"file":"./API/Basic_Methods/resume.html","index":[{"h1":"resume method","body":"","anchorH1":"%60resume%60_method"},{"h1":"resume method","h2":"Description","body":"Un-pause the currently-loaded content. Equivalent to a video element’s play method. play can only be called when the WaspHlsPlayer instance is [in the \"Loaded\"](XXX TODO) state. Note that when initially loaded, the content will be in the paused state. If you want to begin playback, you will thus have to call resume. The returned promise may reject in cases where playing is blocked, such as when “auto-playing” is disabled on the page. You can see this MDN page for more information on why this promise will reject.","anchorH1":"%60resume%60_method","anchorH2":"description"},{"h1":"resume method","h2":"Syntax","body":"const promise = player.resume(); promise.catch((err) => {   console.warn(\"Impossible to play:\", err); });   return value:  Promise: Result of calling play on the media element. That Promise may reject in cases where playing is blocked. You can see this MDN page for more information on why this promise will reject.","anchorH1":"%60resume%60_method","anchorH2":"syntax"}]},{"file":"./API/Basic_Methods/getError.html","index":[{"h1":"getError method","body":"XXX TODO Also XXX TODO, getMediaDuration? Also XXX TODO, getCurrentBufferGap?","anchorH1":"%60geterror%60_method"}]},{"file":"./API/Basic_Methods/stop.html","index":[{"h1":"stop method","body":"XXX TODO","anchorH1":"%60stop%60_method"}]},{"file":"./API/Basic_Methods/addEventListener.html","index":[{"h1":"addEventListener method","body":"","anchorH1":"%60addeventlistener%60_method"},{"h1":"addEventListener method","h2":"Description","body":"Add an event listener to trigger a callback as it happens. The callback will have the event payload as a single argument. The WaspHlsPlayer API is heavily event-based. As an example: to know when a content is loaded, the most straightforward way is to add an event listener for the \"playerStateChange\" event. This can be done only through this method. To have the complete list of player events, consult the Player events page. For example, to listen to errors, you could write: player.addEventListener(\"error\", function (err) {   console.log(`The player stopped with an error: ${err.message}`); }); ","anchorH1":"%60addeventlistener%60_method","anchorH2":"description"},{"h1":"addEventListener method","h2":"Syntax","body":"player.addEventListener(event, callback);    arguments:   event string: The wanted event’s name.   callback Function: The callback for the event. The same callback may be used again when calling removeEventListener.    ","anchorH1":"%60addeventlistener%60_method","anchorH2":"syntax"}]},{"file":"./API/Basic_Methods/removeEventListener.html","index":[{"h1":"removeEventListener method","body":"","anchorH1":"%60removeeventlistener%60_method"},{"h1":"removeEventListener method","h2":"Description","body":"Removes an event listener previously registered through the addEventListener method. This also free-up the corresponding ressources. The callback given is optional: if not given, every registered callback to that event will be removed. For example, to add then remove an event listener for the \"playerStateChange\" event, you can write: const onPlayerStateChange = (state) => {   console.log(\"new player state:\", state); }; player.addEventListener(\"playerStateChange\", onPlayerStateChange); player.removeEventListener(\"playerStateChange\", onPlayerStateChange); ","anchorH1":"%60removeeventlistener%60_method","anchorH2":"description"},{"h1":"removeEventListener method","h2":"Syntax","body":"// Remove all callbacks linked to event player.removeEventListener(event);  // Remove specific listener player.removeEventListener(event, callback);    arguments:   event string: The event name.   callback (optional) Function|undefined: The callback given when calling the corresponding addEventListener API.    ","anchorH1":"%60removeeventlistener%60_method","anchorH2":"syntax"}]},{"file":"./API/Basic_Methods/dispose.html","index":[{"h1":"dispose method","body":"XXX TODO","anchorH1":"%60dispose%60_method"}]},{"file":"./API/Playback_Information/isPlaying.html","index":[{"h1":"isPlaying method","body":"XXX TODO","anchorH1":"%60isplaying%60_method"}]},{"file":"./API/Playback_Information/isPaused.html","index":[{"h1":"isPaused method","body":"XXX TODO","anchorH1":"%60ispaused%60_method"}]},{"file":"./API/Playback_Information/isRebuffering.html","index":[{"h1":"isRebuffering method","body":"XXX TODO","anchorH1":"%60isrebuffering%60_method"}]},{"file":"./API/Playback_Information/isEnded.html","index":[{"h1":"isEnded method","body":"XXX TODO","anchorH1":"%60isended%60_method"}]},{"file":"./API/Position_Control/getPosition.html","index":[{"h1":"getPosition method","body":"XXX TODO","anchorH1":"%60getposition%60_method"}]},{"file":"./API/Position_Control/seek.html","index":[{"h1":"seek method","body":"XXX TODO","anchorH1":"%60seek%60_method"}]},{"file":"./API/Position_Control/getMinimumPosition.html","index":[{"h1":"getMinimumPosition method","body":"XXX TODO","anchorH1":"%60getminimumposition%60_method"}]},{"file":"./API/Position_Control/getMaximumPosition.html","index":[{"h1":"getMaximumPosition method","body":"XXX TODO","anchorH1":"%60getmaximumposition%60_method"}]},{"file":"./API/Position_Control/getMediaOffset.html","index":[{"h1":"getMediaOffset method","body":"XXX TODO","anchorH1":"%60getmediaoffset%60_method"}]},{"file":"./API/Speed_Control/setSpeed.html","index":[{"h1":"setSpeed method","body":"XXX TODO","anchorH1":"%60setspeed%60_method"}]},{"file":"./API/Speed_Control/getSpeed.html","index":[{"h1":"getSpeed method","body":"XXX TODO","anchorH1":"%60getspeed%60_method"}]},{"file":"./API/Variant_Selection/getCurrentVariant.html","index":[{"h1":"getCurrentVariant method","body":"XXX TODO","anchorH1":"%60getcurrentvariant%60_method"}]},{"file":"./API/Variant_Selection/getVariantList.html","index":[{"h1":"getVariantList method","body":"XXX TODO","anchorH1":"%60getvariantlist%60_method"}]},{"file":"./API/Variant_Selection/lockVariant.html","index":[{"h1":"lockVariant method","body":"XXX TODO","anchorH1":"%60lockvariant%60_method"}]},{"file":"./API/Variant_Selection/unlockVariant.html","index":[{"h1":"unlockVariant method","body":"XXX TODO","anchorH1":"%60unlockvariant%60_method"}]},{"file":"./API/Variant_Selection/getLockedVariant.html","index":[{"h1":"getLockedVariant method","body":"XXX TODO","anchorH1":"%60getlockedvariant%60_method"}]},{"file":"./API/Audio_Track_Selection/getCurrentAudioTrack.html","index":[{"h1":"getCurrentAudioTrack method","body":"XXX TODO","anchorH1":"%60getcurrentaudiotrack%60_method"}]},{"file":"./API/Audio_Track_Selection/getAudioTrackList.html","index":[{"h1":"getAudioTrackList method","body":"XXX TODO","anchorH1":"%60getaudiotracklist%60_method"}]},{"file":"./API/Audio_Track_Selection/setAudioTrack.html","index":[{"h1":"setAudioTrack method","body":"XXX TODO","anchorH1":"%60setaudiotrack%60_method"}]}]