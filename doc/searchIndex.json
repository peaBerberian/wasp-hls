[{"file":"./Getting_Started/Welcome.html","index":[{"h2":"WaspHlsPlayer overview","body":"The WaspHlsPlayer is a media player library allowing to play HLS contents on the web efficiently by exploiting a WebWorker, allowing to run concurrently to the user interface and WebAssembly, allowing to do so in an optimized way. The WaspHlsPlayer requires both features to be available in environment it runs. It also support more advanced features, such as MSE-in-Workers on browsers that support them, though it can also run efficiently on environments without those. All of those features should ensure that an heavy UI won’t have a huge influence on media buffering, as well as ensuring that the media loading, parsing and buffering operations won’t be felt when interacting with the page.","anchorH2":"wasphlsplayer_overview"},{"h2":"Very quick start","body":"To let you quickly test the project, the WaspHlsPlayer provides embedded versions of its WebAssembly and Worker files, even if I recommend to store and serve those as separate files on production (more details in the rest of the documentation). You can thus very quickly test the WaspHlsPlayer by just installing it: // With npm npm install wasp-hls  // or with yarn yarn add wasp-hls  And then running the following JavaScript file. import WaspHlsPlayer from \"wasp-hls\"; import EmbeddedWasm from \"wasp-hls/wasm\"; import EmbeddedWorker from \"wasp-hls/worker\";  const player = new WaspHlsPlayer(videoElement); player   .initialize({     workerUrl: EmbeddedWorker,     wasmUrl: EmbeddedWasm,   })   .catch((err) => {     console.error(\"Could not initialize WaspHlsPlayer:\", err);   }); player.load(HLS_MULTIVARIANT_PLAYLIST_URL);  Where HLS_MULTIVARIANT_PLAYLIST_URL is the URL to the main playlist (called either the Multivariant Playlist or the Master Playlist) of your HLS content. Of course, once initialize has succeeded, you can play any HLS content you want on that WaspHlsPlayer instance.","anchorH2":"very_quick_start"},{"h2":"The documentation pages","body":"Those documentation pages are splitted into multiple categories:   You’re here in the “Getting Started” category which provides tutorials and other resources allowing to help you with basic usage of the WaspHlsPlayer.   You can also dive into the API, which specifies the behavior of everything that is possible with the WaspHlsPlayer.  ","anchorH2":"the_documentation_pages"}]},{"file":"./Getting_Started/Creating_a_WaspHlsPlayer.html","index":[{"h1":"Creating a new WaspHlsPlayer","body":"","anchorH1":"creating_a_new_wasphlsplayer"},{"h1":"Creating a new WaspHlsPlayer","h2":"Instantiation","body":"Each WaspHlsPlayer allows to play HLS content on a single video element. That video element has to be provided on instanciation like this: const player = new WaspHlsPlayer(videoElement);  More information on the WaspHlsPlayer’s constructor can be found in the API documentation page presenting the instantiation step. Note that the WaspHlsPlayer’s constructor optionally can take a second argument, which allows to overwrite its initial configuration. More information on this object is available in the API documentation. Before being ready to load contents on that new instance, we now have to “initialize” it, which is an operation described in the next chapter.","anchorH1":"creating_a_new_wasphlsplayer","anchorH2":"instantiation"},{"h1":"Creating a new WaspHlsPlayer","h2":"WaspHlsPlayer initialization","body":"Before it can actually load a content, the WaspHlsPlayer needs to let it have access to two files:   The worker file, which contains code which will run concurrently to your application.   The WebAssembly file, used by the worker file to run efficiently its internal logic.   Both of those files can be retrieved in the release page (you should choose the one linked to your actual WaspHlsPlayer’s version). They then have to be served via HTTP(S) (through a solution of your choosing), and can be communicated to the WaspHlsPlayer through its initialize method: player   .initialize({     workerUrl: \"https://www.example.com/worker.js\",     wasmUrl: \"https://www.example.com/wasp_hls_bg.wasm\",   })   .then(     () => {       console.log(\"WaspHlsPlayer initialized with success!\");     },     (err) => {       console.error(\"Could not initialize WaspHlsPlayer:\", err);     }   );  // we can now use the player (we don't need to await the Promise here)  Alternatively, if you don’t want the hassle of having to serve those files separately when developping, the WaspHlsPlayer also provide both the WebAssembly and Worker files through JavaScript-embedded versions, respectively through the \"wasp-hls/wasm\" and the \"wasp-hls/worker\" path: import EmbeddedWasm from \"wasp-hls/wasm\"; import EmbeddedWorker from \"wasp-hls/worker\";  player   .initialize({     workerUrl: EmbeddedWorker,     wasmUrl: EmbeddedWasm,   })   .then(     () => {       console.log(\"WaspHlsPlayer initialized with success!\");     },     (err) => {       console.error(\"Could not initialize WaspHlsPlayer:\", err);     }   );  // we can now use the player (we don't need to await the Promise here)  Note however that this leads to a huge file size (though which is drastically reduced when compressed) and to some small inefficencies on initialization (as those JavaScript files have to first be interpreted in the main thread), which is why I recommend serving both those files separately for production. It’s also possible to communicate an initial bandwidth estimate through the initialize method to improve the WaspHlsPlayer’s accuracy regarding its initially loaded quality. For more information on this “initialization” step, you can consult the API documentation page dedicated to it, here.","anchorH1":"creating_a_new_wasphlsplayer","anchorH2":"wasphlsplayer_initialization"},{"h1":"Creating a new WaspHlsPlayer","h2":"What if one of my targeted browser don’t support WebAssembly?","body":"For now, the files exposed by the WaspHlsPlayer requires the compatibility with WebAssembly. Note however that tools exist to convert WebAssembly to JavaScript, the reference as of now being binaryen’s wasm2js tool. With it, you may convert the WaspHlsPlayer’s WebAssembly file to JavaScript and provide some bindings yourself (it shouldn’t be too hard, though automating it to facilitate migration to new WaspHlsPlayer versions might take some more work), to also support environments not compatible with WebAssembly.","anchorH1":"creating_a_new_wasphlsplayer","anchorH2":"what_if_one_of_my_targeted_browser_don't_support_webassembly?"}]},{"file":"./API/Overview.html","index":[{"h1":"WaspHlsPlayer API","body":"The API documentation is a thorough guide through every feature exposed by the WaspHlsPlayer, in a logical order. If you are very new to the WaspHlsPlayer and don’t want to dive deep in the API for the moment, you might want to check the Getting Started pages instead.  Only variables and methods defined here are considered as part of the API. Any other property or method you might find in any other way are not considered as part of the API and can thus change without notice. ","anchorH1":"wasphlsplayer_api"}]},{"file":"./API/Instantiation.html","index":[{"h1":"WaspHlsPlayer instantiation","body":"","anchorH1":"wasphlsplayer_instantiation"},{"h1":"WaspHlsPlayer instantiation","h2":"Description","body":"instantiating a WaspHlsPlayer is a necessary step before using most of its API, like load to load a new HLS content. It is here that the HTMLVideoElement (the <video /> HTML element) on which the content will play is given to the WaspHlsPlayer: import WaspHlsPlayer from \"wasp-hls\";  const videoElement = document.querySelector(\"video\"); const player = new WaspHlsPlayer(videoElement);  Note: For a more predictable behavior, it is best that you then use the WaspHlsPlayer’s API instead of any of the HTMLVideoElement’s own methods, attributes and events, excepted when the opposite is explicitely advised by this documentation (such as with audio volume management). Optionally, you can give a second argument on instantiation, the WaspHlsPlayer’s original configuration object: const config = {   // Try to reach a buffer size of 20 seconds when playing   bufferGoal: 20,    // Re-do a segment request if it takes more than 10 seconds   segmentRequestTimeout: 10,    // ... }; const player = new WaspHlsPlayer(videoElement, config);  You may here only define a subset of those keys, in which case the WaspHlsPlayer will set sane default values for the others. You can also either not set it, set it to undefined or to an empty object, in which cases the WaspHlsPlayerConfig will use its inner default configuration instead. Note that this configuration object can be updated at any time through the updateConfig method.","anchorH1":"wasphlsplayer_instantiation","anchorH2":"description"},{"h1":"WaspHlsPlayer instantiation","h2":"Syntax","body":"const player = new WaspHlsPlayer(videoElement);  // or, with a default configuration object const player = new WaspHlsPlayer(videoElement, configObject);    arguments:   videoElement HTMLVideoElement: The <video /> element on the page on which the content will play.   config (optional) Object|undefined: Default configuration object.    ","anchorH1":"wasphlsplayer_instantiation","anchorH2":"syntax"}]},{"file":"./API/Initialization.html","index":[{"h1":"WaspHlsPlayer Initialization","body":"","anchorH1":"wasphlsplayer_initialization"},{"h1":"WaspHlsPlayer Initialization","h2":"Description","body":"Once it has been Instantiated, the WaspHlsPlayer needs to be “initialized”. That initialization task is the step during which the two external parts of the WaspHlsPlayer, namely its worker file and WebAssembly file, are setup. Both of those files can be retrieved in in the release page, note that you should chose the files linked to the WaspHlsPlayer’s version used by your application. After recuperating both of those files, you need to host them, to then provide their URL to the WaspHlsPlayer’s initialize method: player   .initialize({     // URL to the worker file     workerUrl: \"https://www.example.com/worker.js\",      // URL to the WebAssembly file     wasmUrl: \"https://www.example.com/wasp_hls_bg.wasm\",      // Optional initial bandwidth estimate, in bits per seconds.     // Will be relied on before the `WaspHlsPlayer` is able to produce its own     // precize estimate.     // Can be unset or undefined to let the `WaspHlsPlayer` define its own,     // poor, initial value.     initialBandwidth: 200000,   })   .then(     () => {       console.log(\"WaspHlsPlayer initialized with success!\");     },     (err) => {       console.error(\"Could not initialize WaspHlsPlayer:\", err);     }   );  // we can now use the player (we don't need to await the Promise here) ","anchorH1":"wasphlsplayer_initialization","anchorH2":"description"},{"h1":"WaspHlsPlayer Initialization","h2":"Description","h3":"Preventing the need to serve those files separately","body":"Note that if you don’t want the supplementary step of serving both those files for now, the WaspHlsPlayer also provides embedded versions of both. With them, the code would be written as: import EmbeddedWasm from \"wasp-hls/wasm\"; import EmbeddedWorker from \"wasp-hls/worker\";  player   .initialize({     workerUrl: EmbeddedWorker,     wasmUrl: EmbeddedWasm,     initialBandwidth: 200000,   })   .then(     () => {       console.log(\"WaspHlsPlayer initialized with success!\");     },     (err) => {       console.error(\"Could not initialize WaspHlsPlayer:\", err);     }   );  // we can now use the player (we don't need to await the Promise here)  However I don’t recommend relying on embedded versions for production: Those versions lead to a huge file size (though which is drastically reduced when compressed) and to some small inefficencies on initialization (as those JavaScript files have to first be interpreted in the main thread).","anchorH1":"wasphlsplayer_initialization","anchorH2":"description","anchorH3":"preventing_the_need_to_serve_those_files_separately"},{"h1":"WaspHlsPlayer Initialization","h2":"Description","h3":"Be notified of when initialization succeeds (or fails)","body":"As you can see, the initialize method returns a promise, which is only resolved once the initialization process succeeded. That promise might also reject in the following situations:  The provided files could not be requested. An issue happened while trying to run and/or compile the given files  In those cases, the promise returned by initialize will reject. That promise might also reject if the player was disposed (through its dispose method) before initialization finished with success. Note that you don’t have to wait for that condition before using most of the WaspHlsPlayer’s methods, if you for example load a content with the load method before initialization succeeds, it will automatically be loaded once initialization is finished\". You can check the status of the initialization at any time by looking at the WaspHlsPlayer’s initializationStatus property: switch (player.initializationStatus) {   case \"Uninitialized\":     console.log(\"The WaspHlsPlayer has never been initialized.\");     break;    case \"Initializing\":     console.log(\"The WaspHlsPlayer is currently initializing.\");     break;    case \"Initialized\":     console.log(\"The WaspHlsPlayer has been initialized with success.\");     break;    case \"errored\":     console.log(\"The WaspHlsPlayer's initialization has failed.\");     break;    case \"disposed\":     console.log(\"The WaspHlsPlayer's instance has been disposed.\");     break; } ","anchorH1":"wasphlsplayer_initialization","anchorH2":"description","anchorH3":"be_notified_of_when_initialization_succeeds_(or_fails)"},{"h1":"WaspHlsPlayer Initialization","h2":"Description","h3":"Note for the hosting of the WebAssembly file","body":"It is generally recommended for performance reasons to serve WebAssembly files with the a Content-Type HTTP(S) response header set to application-wasm. Note however that this is not an obligation and that the actual performance impact is relatively small.","anchorH1":"wasphlsplayer_initialization","anchorH2":"description","anchorH3":"note_for_the_hosting_of_the_webassembly_file"}]},{"file":"./API/Loading_a_content.html","index":[{"h1":"Loading a content","body":"","anchorH1":"loading_a_content"},{"h1":"Loading a content","h2":"Description","body":"Loading a content through the WaspHlsPlayer can only be done once it has been instantiated and once initialize has been called (it is not necessary to await the returned Promise). This is the step where the URL of the Multivariant Playlist (before known as the “Master Playlist”) is provided to the WaspHlsPlayer, that takes care of media playback. That step is done through the load method, through a very straightforward call: // Here `MultivariantPlaylistUrl` is the HTTP(S) URL to the Multivariant // Playlist player.load(MultivariantPlaylistUrl);  You can then be notified of where the load operation is at (whether it is still loading the content, has loaded it or encountered an error) by either listening to the \"playerStateChange\" event or at any point in time by calling the getPlayerState method: player.addEventlistener(\"playerStateChange\", (playerState) => {   switch (playerState) {     case \"Loading\":       console.log(\"A new content is loading.\");       break;     case \"Loaded\":       console.log(\"The last loaded content is currently loaded.\");       break;     case \"Error\":       console.log(         \"The last loaded content cannot play anymore due to an error.\"       );       break;     case \"Stopped\":       console.log(\"No content is currently loaded nor loading.\");       break;   } });  Note that the WaspHlsPlayer doesn’t automatically begin playback once the content is loaded. To do so, you have to call the resume method once the \"Loaded\" player state is reached: // Automatically play the content once it's loaded player.addEventlistener(\"playerStateChange\", (playerState) => {   if (playerState === \"Loaded\") {     player.resume();   } }); ","anchorH1":"loading_a_content","anchorH2":"description"},{"h1":"Loading a content","h2":"Options","body":"load also can take an optional second argument, an object representing its options. For now there’s only one optional property that can be set inside it, startingPosition.","anchorH1":"loading_a_content","anchorH2":"options"},{"h1":"Loading a content","h2":"Options","h3":"startingPosition","body":"type: number | object | undefined The startingPosition option allows to indicate a preferred position at which playback should begin. If not set or set to undefined, the WaspHlsPlayer will decide by itself where to begin in the content, based on content information. In most cases, this is what you want. As a number If you do want to start at a specific position, startingPosition can be set as a number, which will corresponds to the wanted starting position, in terms of content time (the position as deduced from the HLS Media Playlists, which may not be the same than the media time inside media segments) in seconds. For example, to begin playback of a VoD content at the second 10, you can write: player.load(playlistUrl, {   startingPosition: 10, });  Or to play some live contents at what was recorded one minute ago, you could write: // Unix timestamp, in seconds, corresponding to now minus 1 minute const date = Date.now() / 1000 - 60;  player.load(playlistUrl, {   startingPosition: date, });  As an object More complex relative wanted starting positions can be communicated by setting startingPosition to an object instead. Those objects each have two properties, startType, a string indicating the type of relative or absolute position, and position indicating the position value. A relative position to the initially minimum or maximum position can this way be given respectively by setting startType to \"FromBeginning\" and \"FromEnd\". For example, to start playback 10 seconds before the last initially available position (10 seconds before the end for a VoD content, or before live for a live content), you can write: player.load(playlistUrl, {   startingPosition: {     startType: \"FromEnd\",     position: 10,   }, });  If you however want to play 10 seconds after the first initially available position, you can write: player.load(playlistUrl, {   startingPosition: {     startType: \"FromBeginning\",     position: 10,   }, });  For completeness-sake, it’s also possible to communicate through an object an absolute position, exactly as if a number was directly communicated, you can do so through the \"Absolute\" startType. Thus to start at exactly the second 30, you can write: player.load(playlistUrl, {   startingPosition: {     startType: \"Absolute\",     position: 30,   }, }); ","anchorH1":"loading_a_content","anchorH2":"options","anchorH3":"%60startingposition%60"}]},{"file":"./API/Player_Events.html","index":[{"h1":"Player Events","body":"","anchorH1":"player_events"},{"h1":"Player Events","h2":"Overview","body":"As it begins to load a content, the WaspHlsPlayer will send various events allowing you:  to let you know the current playback conditions what audio tracks are available and which one is selected what variants (i.e. qualities) are available and which one is selected and so on  This page will document every one of them.","anchorH1":"player_events","anchorH2":"overview"},{"h1":"Player Events","h2":"Listening to an event","body":"The WaspHlsPlayer copies the same event listening API than the EventTarget you’re generally used to on the web. That is, you can use a method called addEventlistener to register a callback on an event and removeEventListener to remove it. For example, to add then immediately remove an event listener for the \"playerStateChange\" event, you can write: const onPlayerStateChange = (state) => {   console.log(\"new player state:\", state); }; player.addEventListener(\"playerStateChange\", onPlayerStateChange); player.removeEventListener(\"playerStateChange\", onPlayerStateChange); ","anchorH1":"player_events","anchorH2":"listening_to_an_event"},{"h1":"Player Events","h2":"Event: playerStateChange","body":"The \"playerStateChange\" event is sent when the “state” of playback is updpated, with a string describing that new state as a payload. This is the event you want to listen to to be alerted when your loaded content can start to play, or when it was actually stopped. The various values that this state can be set to are:   \"Stopped\": The content has just been stopped. No content is playing anymore.   \"Loading\": Set synchronously when the load method is called, to indicate that a new content is being loaded.   \"Loaded\": the last content loaded with load is now ready to play.   \"Error\": the last content loaded with load has been interrupted due to an error. An \"error\" event should also have been triggered. You can also know which error happened by calling the getError method.   As such, for example to automatically play when the content is loaded, you can combine this event with a call to resume, by writing: player.addEventListener(\"playerStateChange\", (state) => {   if (state === \"Loaded\") {     // auto-play when loaded     player.resume();   } });  You can also know the player’s state at any time by calling the getPlayerState method.","anchorH1":"player_events","anchorH2":"event:_%60playerstatechange%60"},{"h1":"Player Events","h2":"Event: paused","body":"The \"paused\" event is sent when a loaded content (which is a content which currently is in the \"Loaded\" state was just paused, generally due to a previous call to the pause method. It may also be triggered when we reach the end of the content (in which case, the isEnd method will return true and you’ll also receive an ended event). This event doesn’t have a payload. Example of usage: player.addEventListener(\"paused\", () => {   console.log(\"Playback is now effectively paused.\"); });  You can also know whether playback is currently paused at any time by calling the isPaused method.","anchorH1":"player_events","anchorH2":"event:_%60paused%60"},{"h1":"Player Events","h2":"Event: playing","body":"The \"playing\" event is sent when a loaded content (which is a content which currently is in the \"Loaded\" state went out of a “paused” status, generally due to a previous call to the resume method. This event doesn’t have a payload. Example of usage: player.addEventListener(\"playing\", () => {   console.log(\"Playback is now effectively playing.\"); });  You can also know whether playback is currently playing at any time by calling the isPlaying method.","anchorH1":"player_events","anchorH2":"event:_%60playing%60"},{"h1":"Player Events","h2":"Event: ended","body":"The \"ended\" event is sent when playback reached the end of the content. Playback is now paused, generally at the last video frame visible of the content. This event doesn’t have a payload. Example of usage: player.addEventListener(\"ended\", () => {   console.log(\"Playback is now ended.\"); });  You can also know whether the end is currently reached at any time by calling the isEnded method.","anchorH1":"player_events","anchorH2":"event:_%60ended%60"},{"h1":"Player Events","h2":"Event: error","body":"The \"error\" event is sent when an error interrupted playback of the last content. The corresponding Error object is sent as a payload. For more information on the potential errors see the Errors and warnings page. Example of a callback registered to that event: player.addEventListener(\"error\", (error) => {   console.error(\"An error just stopped playback:\", error); });  Just before the \"error\" event is sent, the player’s start (as returned by the getPlayerState method and emitted by the playerStateChange event are set to \"Error\". Also, the getError method should now return the same error object than the one emitted as a payload of the error event, until another content is loaded or until stop is called, whichever comes first.","anchorH1":"player_events","anchorH2":"event:_%60error%60"},{"h1":"Player Events","h2":"Event: warning","body":"The \"warning\" event is sent when a minor error happened, though unlike the error event, it hasn’t resulted in playback interruption. The corresponding Error object is sent as a payload. For more information on the potential errors see the Errors and warnings page. Example of a callback registered to that event: player.addEventListener(\"warning\", (error) => {   console.warn(\"A minor error just happened:\", error); }); ","anchorH1":"player_events","anchorH2":"event:_%60warning%60"},{"h1":"Player Events","h2":"Event: rebufferingStarted","body":"The \"rebufferingStarted\" event is sent when a loaded content (which is a content which currently is in the \"Loaded\" state just began rebuffering. Rebuffering is a period during which playback is paused to build back buffer, in that condition, playback will only restart (by itself) once enough buffer is loaded. Rebuffering can for example happen if the network bandwidth is currently too low to play sustainably the current content or due to some other event like a seek. Note that rebuffering can also happen when playback is paused. It just means that there’s not enough media data to begin playback. This event doesn’t have a payload. Example of usage: player.addEventListener(\"rebufferingStarted\", () => {   console.log(\"Playback is now paused due to a started rebuffering period\"); });  You can also know whether playback is currently rebuffering at any time by calling the isRebuffering method.","anchorH1":"player_events","anchorH2":"event:_%60rebufferingstarted%60"},{"h1":"Player Events","h2":"Event: rebufferingEnded","body":"The \"rebufferingEnded\" event is sent when a loaded content (which is a content which currently is in the \"Loaded\" state just exited a rebuffering period. You should have previously received a \"rebufferingStarted\" event when that rebuffering period had started. Rebuffering is a period during which playback is paused to build back buffer, in that condition, playback will only restart (by itself) once enough buffer is loaded. Rebuffering can for example happen if the network bandwidth is currently too low to play sustainably the current content or due to some other event like a seek. Note that rebuffering can also happen when playback is paused. It just means that there’s not enough media data to begin playback. This event doesn’t have a payload. Example of usage: player.addEventListener(\"rebufferingEnded\", () => {   console.log(\"Playback can now restart as we're exited a rebuffering period.\"); });  You can also know whether playback is currently rebuffering at any time by calling the isRebuffering method.","anchorH1":"player_events","anchorH2":"event:_%60rebufferingended%60"},{"h1":"Player Events","h2":"Event: contentInfoUpdate","body":"The \"contentInfoUpdate\" event is sent when the following characteristics of the last loaded content are either known or updated:   The “minimum position” reachable in the content.   The “maximum position” reachable in the content.   Whether the current content is a “live content”.   Whether the current content is a “VOD content”.   The payload of that event is an object with the following self-explanatory properties:   minimumPosition (number | undefined): the new minimum position.   maximumPosition (number | undefined): the new maximum position.   isLive (boolean): If true, the content is a live content.   isVod (boolean): If true, the content is a VoD content.  ","anchorH1":"player_events","anchorH2":"event:_%60contentinfoupdate%60"},{"h1":"Player Events","h2":"Event: variantUpdate","body":"The \"variantUpdate event is sent when the currently-loaded variant, which basically represents the video and audio qualities, has changed. Note that the variantUpdate is only about the variant being loaded, which may be different than the one being currently played (you’re generally playing already-loaded content). The payload of that event contains the information available on that variant if known, or undefined if the characteristics of the variant is unknown. When set to an object, it should contain the following keys:   id (number): The identifier for that variant. Might be useful for example when wanting to lock that variant in place through the lockVariant method.   width (number | undefined): The optimal width at which the video media data linked to that variant is displayed, in pixel. undefined if unknown or if there’s no video data.   height (number | undefined): The optimal height at which the video media data linked to that variant is displayed, in pixel. undefined if unknown or if there’s no video data.   frameRate (number | undefined): The maximum frame for the video media data linked to that variant. undefined if unknown or if there’s no video data.   bandwidth (number | undefined): The peak segment bit rate of any media combination in that variant, in bits per second. undefined if unknown,   You can also know at any time the same characteristics of the current variant by calling the getCurrentVariant method.","anchorH1":"player_events","anchorH2":"event:_%60variantupdate%60"},{"h1":"Player Events","h2":"Event: variantLockUpdate","body":"The \"variantLockUpdate event is sent when the current variant has been “locked” or unlocked. A variant lock is the result of calling the lockVariant method, which allows to force a given variant (e.g. manually forcing 1080p video content). When a single variant is forced, we say that it is “locked”, when the WaspHlsPlayer actually chooses its variant amongst the pool of currenly-available ones, we say that it is “unlocked”. This variant may be locked due to various events. For example due to a unlockVariant call or due to a change of track (e.g. through the setAudioTrack method) incompatible with the locked variant. When the variant is actually “unlocked”, the payload of that event will be null. When the variant is now “locked”, it is set to an object representing that variant’s characteristics. That object will have the following keys (same than for the variantUpdate event):   id (number): The identifier for that variant. Might be useful for example when wanting to lock that variant in place through the lockVariant method.   width (number | undefined): The optimal width at which the video media data linked to that variant is displayed, in pixel. undefined if unknown or if there’s no video data.   height (number | undefined): The optimal height at which the video media data linked to that variant is displayed, in pixel. undefined if unknown or if there’s no video data.   frameRate (number | undefined): The maximum frame for the video media data linked to that variant. undefined if unknown or if there’s no video data.   bandwidth (number | undefined): The peak segment bit rate of any media combination in that variant, in bits per second. undefined if unknown,   If that change of lock status led to a change of currently-loaded variant, you’ll also receive a variantUpdate event. You can know at any time whether a variant is currently locked and which one from the getLockedVariant method.","anchorH1":"player_events","anchorH2":"event:_%60variantlockupdate%60"},{"h1":"Player Events","h2":"Event: variantListUpdate","body":"The \"variantListUpdate event is sent when the list of available variants, which basically represent the video and audio qualities, has changed. The payload of that event contains an array object, each object containing the information available for a particular variant. Each object should contain the following keys (same than for the variantUpdate event):   id (number): The identifier for that variant. Might be useful for example when wanting to lock that variant in place through the lockVariant method.   width (number | undefined): The optimal width at which the video media data linked to that variant is displayed, in pixel. undefined if unknown or if there’s no video data.   height (number | undefined): The optimal height at which the video media data linked to that variant is displayed, in pixel. undefined if unknown or if there’s no video data.   frameRate (number | undefined): The maximum frame for the video media data linked to that variant. undefined if unknown or if there’s no video data.   bandwidth (number | undefined): The peak segment bit rate of any media combination in that variant, in bits per second. undefined if unknown,   You can also know at any time the list of available variants by calling the getVariantList method.","anchorH1":"player_events","anchorH2":"event:_%60variantlistupdate%60"},{"h1":"Player Events","h2":"Event: audioTrackUpdate","body":"The \"audioTrackUpdate event is sent when the currently-loaded audio track has changed. Note that what we call “audio track” here may actually be a set of multiple audio qualities (generally dispatched in various variants) all with the same characteristics (same language, same name, same accessibility, same number of channels etc.). The payload of that event contains the information available on that audio track if known, or undefined either if the characteristics of the audio track is unknown or if no audio track is active. When set to an object, it should contain the following keys:   id (number): The identifier for that audio track. It is generally useful to for example set the audio track though a setAudioTrack call.   language (string | undefined): The primary language used in this audio track, as a language tag. undefined if unknown or if there’s no language involved.   assocLanguage (string | undefined): A secondary language associated to the audio track, as a language tag. Such language is often used in a different role than the language specified through the language property (e.g., written versus spoken, or a fallback dialect). undefined if unknown or if there’s no language involved.   name (string): Human-readable description of the audio track. If the language property is set, it should generally be in that language.   channels (number | undefined): If set, it is the count of audio channels, indicating the maximum number of independent and simultaneous audio channels present in any media data in that audio track. For example, an AC-3 5.1 Rendition would have a channels attribute set to 6.   You can also know at any time the same characteristics of the current audio track by calling the getCurrentAudioTrack method.","anchorH1":"player_events","anchorH2":"event:_%60audiotrackupdate%60"},{"h1":"Player Events","h2":"Event: audioTrackListUpdate","body":"The \"audioTrackListUpdate event is sent when the list of available audio tracks has changed. The payload of that event contains an array object, each object containing the information available for a particular audio track. Each object should contain the following keys (same than for the audioTrackUpdate event):   id (number): The identifier for that audio track. It is generally useful to for example set the audio track though a setAudioTrack call.   language (string | undefined): The primary language used in this audio track, as a language tag. undefined if unknown or if there’s no language involved.   assocLanguage (string | undefined): A secondary language associated to the audio track, as a language tag. Such language is often used in a different role than the language specified through the language property (e.g., written versus spoken, or a fallback dialect). undefined if unknown or if there’s no language involved.   name (string): Human-readable description of the audio track. If the language property is set, it should generally be in that language.   channels (number | undefined): If set, it is the count of audio channels, indicating the maximum number of independent and simultaneous audio channels present in any media data in that audio track. For example, an AC-3 5.1 Rendition would have a channels attribute set to 6.   You can also know at any time the list of available audio tracks by calling the getAudioTrackList method.","anchorH1":"player_events","anchorH2":"event:_%60audiotracklistupdate%60"}]},{"file":"./API/Configuration_Object.html","index":[{"h1":"Player Configuration","body":"","anchorH1":"player_configuration"},{"h1":"Player Configuration","h2":"Overview","body":"On WaspHlsPlayer instantiation, a configuration object is created and associated to this instance. It allows to configure many aspects of the player, from how much buffer you would prefer to build to how many request retry should be performed if some fails, and any of it can be updated at any time, even when a content impacted by it is playing. An initial config can optionally be given on instantiation (as indicated in the corresponding API documentation page). If not set, a sane default configuration will be generated instead by the WaspHlsPlayer. Any property of that configuration may also be updated at any time through the updateConfig call. For example, to update the bufferGoal property to 20 seconds, you can write: player.updateConfig({   bufferGoal: 20, });  Note that because most of that configuration’s values are actually relied on by code running in a worker, there’s a necessary delay before it actually becomes considered (it doesn’t happen synchronously). The last version of that configuration can also be recuperated through the getConfig method. The rest of this page is going to focus on each properties declared on this configuration object.","anchorH1":"player_configuration","anchorH2":"overview"},{"h1":"Player Configuration","h2":"bufferGoal","body":"type: number Amount of buffer, in seconds, to “build” ahead of the currently wated position. Once that amount is reached, we’ll stop loading new data until we go under again. A lower value will mean less memory and network resources are generally taken, but more risk of rebuffering. A higher value will mean the opposite. A value in the 15-50 range is generally safe.","anchorH1":"player_configuration","anchorH2":"%60buffergoal%60"},{"h1":"Player Configuration","h2":"segmentMaxRetry","body":"type: number Amount of times a failed segment request might be retried on errors that seem temporary (such as an HTTP 404 for example):  1 meaning it will be retried once 2 twice 0 never retried etc.  To set to -1 for infinite retry. Do not be scared to put a high value if you would prefer to retry over stopping on error. There’s an “exponential backoff” mechanism whose main objective is to avoid overloading servers and network resources. So retry never will happen in a quick loop.","anchorH1":"player_configuration","anchorH2":"%60segmentmaxretry%60"},{"h1":"Player Configuration","h2":"segmentRequestTimeout","body":"type: number Number of milliseconds after which a segment request with no response will be automatically cancelled due to a “timeout”. Depending on the configuration, the segment request might then be retried. To set to -1 for disabling segment request timeouts.","anchorH1":"player_configuration","anchorH2":"%60segmentrequesttimeout%60"},{"h1":"Player Configuration","h2":"segmentBackoffBase","body":"type: number If a segment request has to be retried, we will wait an amount of time before restarting the request. That delay raises if the same segment request fails multiple consecutive times, starting from around this value in milliseconds to segmentBackoffMax milliseconds. The step at which it raises is not configurable here, but can be resumed as a power of 2 raise on the previous value each time.","anchorH1":"player_configuration","anchorH2":"%60segmentbackoffbase%60"},{"h1":"Player Configuration","h2":"segmentBackoffMax","body":"type: number If a segment request has to be retried, we will wait an amount of time before restarting the request. That delay raises if the same segment request fails multiple consecutive times, starting from around segmentBackoffBase milliseconds to this value in milliseconds. The step at which it raises is not configurable here, but can be resumed as a power of 2 raise on the previous value each time.","anchorH1":"player_configuration","anchorH2":"%60segmentbackoffmax%60"},{"h1":"Player Configuration","h2":"multiVariantPlaylistMaxRetry","body":"type: number Amount of times a failed Multivariant Playlist request might be retried on errors that seem temporary (such as an HTTP 404 for example):  1 meaning it will be retried once 2 twice 0 never retried etc.  To set to -1 for infinite retry. Do not be scared to put a high value if you would prefer to retry over stopping on error. There’s an “exponential backoff” mechanism whose main objective is to avoid overloading servers and network resources. So retry never will happen in a quick loop.","anchorH1":"player_configuration","anchorH2":"%60multivariantplaylistmaxretry%60"},{"h1":"Player Configuration","h2":"multiVariantPlaylistRequestTimeout","body":"type: number Number of milliseconds after which a Multivariant Playlist request with no response will be automatically cancelled due to a “timeout”. Depending on the configuration, the Multivariant Playlist request might then be retried. To set to -1 for disabling Multivariant Playlist request timeouts.","anchorH1":"player_configuration","anchorH2":"%60multivariantplaylistrequesttimeout%60"},{"h1":"Player Configuration","h2":"multiVariantPlaylistBackoffBase","body":"type: number If a Multivariant Playlist request has to be retried, we will wait an amount of time before restarting the request. That delay raises if the same request fails multiple consecutive times, starting from around this value in milliseconds to multiVariantPlaylistBackoffMax milliseconds. The step at which it raises is not configurable here, but can be resumed as a power of 2 raise on the previous value each time.","anchorH1":"player_configuration","anchorH2":"%60multivariantplaylistbackoffbase%60"},{"h1":"Player Configuration","h2":"multiVariantPlaylistBackoffMax","body":"type: number If a Multivariant Playlist request has to be retried, we will wait an amount of time before restarting the request. That delay raises if the same request fails multiple consecutive times, starting from around multiVariantPlaylistBackoffBase milliseconds to this value in milliseconds. The step at which it raises is not configurable here, but can be resumed as a power of 2 raise on the previous value each time.","anchorH1":"player_configuration","anchorH2":"%60multivariantplaylistbackoffmax%60"},{"h1":"Player Configuration","h2":"mediaPlaylistMaxRetry","body":"type: number Amount of times a failed Media Playlist request might be retried on errors that seem temporary (such as an HTTP 404 for example):  1 meaning it will be retried once 2 twice 0 never retried etc.  To set to -1 for infinite retry. Do not be scared to put a high value if you would prefer to retry over stopping on error. There’s an “exponential backoff” mechanism whose main objective is to avoid overloading servers and network resources. So retry never will happen in a quick loop.","anchorH1":"player_configuration","anchorH2":"%60mediaplaylistmaxretry%60"},{"h1":"Player Configuration","h2":"mediaPlaylistRequestTimeout","body":"type: number Number of milliseconds after which a Media Playlist request with no response will be automatically cancelled due to a “timeout”. Depending on the configuration, the Media Playlist request might then be retried. To set to -1 for disabling Media Playlist request timeouts.","anchorH1":"player_configuration","anchorH2":"%60mediaplaylistrequesttimeout%60"},{"h1":"Player Configuration","h2":"mediaPlaylistBackoffBase","body":"type: number If a Media Playlist request has to be retried, we will wait an amount of time before restarting the request. That delay raises if the same request fails multiple consecutive times, starting from around this value in milliseconds to mediaPlaylistBackoffMax milliseconds. The step at which it raises is not configurable here, but can be resumed as a power of 2 raise on the previous value each time.","anchorH1":"player_configuration","anchorH2":"%60mediaplaylistbackoffbase%60"},{"h1":"Player Configuration","h2":"mediaPlaylistBackoffMax","body":"type: number If a Media Playlist request has to be retried, we will wait an amount of time before restarting the request. That delay raises if the same request fails multiple consecutive times, starting from around mediaPlaylistBackoffBase milliseconds to this value in milliseconds. The step at which it raises is not configurable here, but can be resumed as a power of 2 raise on the previous value each time.","anchorH1":"player_configuration","anchorH2":"%60mediaplaylistbackoffmax%60"}]},{"file":"./API/Player_Errors.html","index":[{"h1":"Player Errors","body":"","anchorH1":"player_errors"},{"h1":"Player Errors","h2":"Overview","body":"Player errors are Error objects which are sent an issue linked to the playback of the last-loaded content arised. All errors in the WaspHlsPlayer follow a common format, with a name, message, code and globalCode property. Some more specific errors have more descriptive properties. All of those are defined in this documentation page.","anchorH1":"player_errors","anchorH2":"overview"},{"h1":"Player Errors","h2":"Fatal errors and warnings","body":"There is two distincts types of errors:   “Fatal” errors, which are major errors led to playback interruption. Such errors are sent through a \"error\" event and are then returned by the getError method once the \"error\" event has been triggered for the current content.   warnings, which are minor errors, sent through the \"warning\" event.   Thus you can know if you received a fatal error (which thus interrupted playback) or a warning (for which the WaspHlsPlayer is capable of staying resilient to) based on the event and/or API which sent it.","anchorH1":"player_errors","anchorH2":"fatal_errors_and_warnings"},{"h1":"Player Errors","h2":"Common structure of a WaspHlsPlayer’s error","body":"All fatal errors and warnings follow the same structure. They extend the JavaScript Error Object and add multiple properties giving more indication over the issue encountered. All the following properties are common to all errors (sent through \"warning\" and \"error\" events, as well as returned by the getError method):   name (string): The type of error received. The name property basically reflects the category of the error received (see below for the different types). When using TypeScript in your application, checking the name property first also allows to provide much better type suggestions when using the code prorperty of that same error.   message (string): A human-readable description of the Error, This message property might change from version to version.   code (string): An error code identifying the exact error encountered. Unlike message, the code property is intented to be stable and as such may be used programatically for error detection. The code should be sufficient to identify a particular error in your application. The name property only allowing to identify the particular type of Error instance you’re currently handling if you want to check the error Object’s properties. More details on that below.   globalCode (string): Contains the exact same value as the code property. We provide both for technical TypeScript-related reasons. globalCode is typed as an union of all potential code strings that may be returned by the WaspHlsPlayer in general, whereas code is typed as an union of code strings that may be linked to error with the same name. Both are correct in terms of type-checking, code being typed as a still valid sub-set of the globalCode property. The main difference will be when you rely on TypeScript to handle that error: In code handling all error objects without first checking the name property, TypeScript will give better autocompletion results when using globalCode. However if you filtered by name in your code, then code will be the most precize one.  ","anchorH1":"player_errors","anchorH2":"common_structure_of_a_%60wasphlsplayer%60's_error"},{"h1":"Player Errors","h2":"Error type: WaspMultivariantPlaylistRequestError","body":"WaspMultivariantPlaylistRequestError are errors triggered when an error arised while doing the Multivariant Playlist HTTP(S) request. Its name property is set to \"WaspMultivariantPlaylistRequestError\". For example to catch when a fatal error was due to a failure to request the Multivariant Playlist, you can write: player.addEventlistener(\"error\", (error) => {     if (error.name === \"WaspMultivariantPlaylistRequestError\") {         // This error was due to a request failure of the Multivariant Playlist     } });  WaspMultivariantPlaylistRequestError also may have the following property:   status (number|undefined: The failed request’s HTTP(S) response status. undefined if unknown, not checked or if not yet received (e.g. in case of a timeout).  ","anchorH1":"player_errors","anchorH2":"error_type:_%60waspmultivariantplaylistrequesterror%60"},{"h1":"Player Errors","h2":"Error type: WaspMultivariantPlaylistRequestError","h3":"Error codes","body":"A WaspMultivariantPlaylistRequestError’s code property can be set to any of the following values:   \"MultivariantPlaylistBadHttpStatus\": The HTTP(s) status on the response indicated that the Multivariant Playlist could not be fetched.   \"MultivariantPlaylistRequestTimeout\": The HTTP(s) request for the Multivariant Playlist timeouted according to the current configuration.   \"MultivariantPlaylistRequestError\": The HTTP(s) request itself failed to be performed (might be because we’re offline, might be because of security policies etc.) for the Multivariant Playlist.   \"MultivariantPlaylistRequestOtherError\": The HTTP(s) request itself failed to be performed for another, unknown, reason for the Multivariant Playlist.  ","anchorH1":"player_errors","anchorH2":"error_type:_%60waspmultivariantplaylistrequesterror%60","anchorH3":"error_codes"},{"h1":"Player Errors","h2":"Error type: WaspMultivariantPlaylistParsingError","body":"WaspMultivariantPlaylistParsingError are errors triggered when an error arised while parsing the Multivariant Playlist. Its name property is set to \"WaspMultivariantPlaylistParsingError\". For example to catch when a fatal error was due to a failure to parse the Multivariant Playlist, you can write: player.addEventlistener(\"error\", (error) => {     if (error.name === \"WaspMultivariantPlaylistParsingError\") {         // This error was due to a parsing failure of the Multivariant Playlist     } }); ","anchorH1":"player_errors","anchorH2":"error_type:_%60waspmultivariantplaylistparsingerror%60"},{"h1":"Player Errors","h2":"Error type: WaspMultivariantPlaylistParsingError","h3":"Error codes","body":"A WaspMultivariantPlaylistParsingError’s code property can be set to any of the following values:   \"MultivariantPlaylistMissingExtM3uHeader\": The first line of the Multivariant Playlist is not #EXTM3U. Are you sure this is a Multivariant Playlist?   \"MultivariantPlaylistWithoutVariant\": The Multivariant Playlist has no variant. Are you sure this is a Multivariant Playlist and not a Media Playlist?   \"MultivariantPlaylistMissingUriLineAfterVariant\": An EXT-X-STREAM-INF tag announced in the Multivariant Playlist, describing an HLS variant, had no URI associated to it. It should be mandatory.   \"MultivariantPlaylistVariantMissingBandwidth\": An EXT-X-STREAM-INF tag announced in the Multivariant Playlist, describing an HLS variant, had no BANDWIDTH attribute associated to it. It should be mandatory.   \"MultivariantPlaylistMediaTagMissingType\": An EXT-X-MEDIA tag announced in the Multivariant Playlist, describing an HLS variant, had no TYPE attribute associated to it. It should be mandatory.   \"MultivariantPlaylistMediaTagMissingName\": An EXT-X-MEDIA tag announced in the Multivariant Playlist, describing an HLS variant, had no NAME attribute associated to it. It should be mandatory.   \"MultivariantPlaylistMediaTagMissingGroupId\": An EXT-X-MEDIA tag announced in the Multivariant Playlist, describing an HLS variant, had no GROUP-ID attribute associated to it. It should be mandatory.   \"MultivariantPlaylistOtherParsingError\": An uncategorized error arised while parsing the Multivariant Playlist.   \"MultivariantPlaylistInvalidValue\": A value in the Multivariant Playlist was in an invalid format.  ","anchorH1":"player_errors","anchorH2":"error_type:_%60waspmultivariantplaylistparsingerror%60","anchorH3":"error_codes_(1)"},{"h1":"Player Errors","h2":"Error type: WaspMediaPlaylistRequestError","body":"WaspMediaPlaylistRequestError are errors triggered when an error arised while doing a Media Playlist HTTP(S) request. Its name property is set to \"WaspMediaPlaylistRequestError\". For example to catch when a fatal error was due to a failure to request a Media Playlist, you can write: player.addEventlistener(\"error\", (error) => {     if (error.name === \"WaspMediaPlaylistRequestError\") {         // This error was due to a request failure of a Media Playlist     } });  WaspMediaPlaylistRequestError also may have the following properties:   status (number|undefined: The failed request’s HTTP(S) response status. undefined if unknown, not checked or if not yet received (e.g. in case of a timeout).   mediaType (string): The “media type” associated to that Media Playlist. Examples of media types are \"Audio\" for a Media Playlist linked to resources containing just audio media content, and \"Video\" for a Media Playlist which contains video content (it may be only video, video with audio, with captions etc.).  ","anchorH1":"player_errors","anchorH2":"error_type:_%60waspmediaplaylistrequesterror%60"},{"h1":"Player Errors","h2":"Error type: WaspMediaPlaylistRequestError","h3":"Error codes","body":"A WaspMediaPlaylistRequestError’s code property can be set to any of the following values:   \"MediaPlaylistBadHttpStatus\": The HTTP(s) status on the response indicated that the Media Playlist could not be fetched.   \"MediaPlaylistRequestTimeout\": The HTTP(s) request for the Media Playlist timeouted according to the current configuration.   \"MediaPlaylistRequestError\": The HTTP(s) request itself failed to be performed (might be because we’re offline, might be because of security policies etc.) for the Media Playlist.   \"MediaPlaylistRequestOtherError\": The HTTP(s) request itself failed to be performed for another, unknown, reason for the Media Playlist.  ","anchorH1":"player_errors","anchorH2":"error_type:_%60waspmediaplaylistrequesterror%60","anchorH3":"error_codes_(2)"},{"h1":"Player Errors","h2":"Error type: WaspMediaPlaylistParsingError","body":"WaspMediaPlaylistParsingError are errors triggered when an error arised while parsing a Media Playlist. Its name property is set to \"WaspMediaPlaylistParsingError\". For example to catch when a fatal error was due to a failure to parse a Media Playlist, you can write: player.addEventlistener(\"error\", (error) => {     if (error.name === \"WaspMediaPlaylistParsingError\") {         // This error was due to a parsing failure of a Media Playlist     } });  WaspMediaPlaylistParsingError also may have the following property:   mediaType (string): The “media type” associated to that Media Playlist. Examples of media types are \"Audio\" for a Media Playlist linked to resources containing just audio media content, and \"Video\" for a Media Playlist which contains video content (it may be only video, video with audio, with captions etc.).  ","anchorH1":"player_errors","anchorH2":"error_type:_%60waspmediaplaylistparsingerror%60"},{"h1":"Player Errors","h2":"Error type: WaspMediaPlaylistParsingError","h3":"Error codes","body":"A WaspMediaPlaylistParsingError’s code property can be set to any of the following values:   \"MediaPlaylistUnparsableExtInf\": An #EXTINF tag announced in the Media Playlist was not in the right format.   \"MediaPlaylistUriMissingInMap\": An #EXT-X-MAP tag in the Media Playlist didn’t its mandatory URI attribute.   \"MediaPlaylistMissingTargetDuration\": There was no #EXT-X-TARGETDURATION tag in the Media Playlist.   \"MediaPlaylistUriWithoutExtInf\": One of the URI found in the MediaPlaylist wasn’t associated to any #EXTINF tag.   \"MediaPlaylistUnparsableByteRange\": A #EXT-X-BYTERANGE tag or a BYTERANGE attribute in the Media Playlist was not in the right format.   \"MediaPlaylistOtherParsingError\": Another uncategorized error happened while parsing the Media Playlist.  ","anchorH1":"player_errors","anchorH2":"error_type:_%60waspmediaplaylistparsingerror%60","anchorH3":"error_codes_(3)"},{"h1":"Player Errors","h2":"Error type: WaspSegmentRequestError","body":"WaspSegmentRequestError are errors triggered when an error arised while doing a segment HTTP(S) request. Its name property is set to \"WaspSegmentRequestError\". For example to catch when a fatal error was due to a failure to request a segment, you can write: player.addEventlistener(\"error\", (error) => {     if (error.name === \"WaspSegmentRequestError\") {         // This error was due to a request failure of a segment     } });  WaspSegmentRequestError also may have the following property:   isInit (boolean|undefined): If true, the error concerns an initialization segment (a segment without media data, intented for lower-level media decoders initialization). If false, it concerns a media segment (a segment with media data). If undefined it is not known whether it concerns an initialization or media segment.  ","anchorH1":"player_errors","anchorH2":"error_type:_%60waspsegmentrequesterror%60"},{"h1":"Player Errors","h2":"Error type: WaspSegmentRequestError","h3":"Error codes","body":"A WaspSegmentRequestError’s code property can be set to any of the following values:   \"SegmentBadHttpStatus\": The HTTP(s) status on the response indicated that the segment could not be fetched.   \"SegmentRequestTimeout\": The HTTP(s) request for the segment timeouted according to the current configuration.   \"SegmentRequestError\": The HTTP(s) request itself failed to be performed (might be because we’re offline, might be because of security policies etc.) for the Media Playlist.   \"SegmentRequestOtherError\": The HTTP(s) request itself failed to be performed for another, unknown, reason for the segment.  ","anchorH1":"player_errors","anchorH2":"error_type:_%60waspsegmentrequesterror%60","anchorH3":"error_codes_(4)"},{"h1":"Player Errors","h2":"Error type: WaspSegmentParsingError","body":"WaspSegmentParsingError are errors triggered when an error arised while parsing a media or initialisation segment. Its name property is set to \"WaspSegmentParsingError\": player.addEventlistener(\"error\", (error) => {     if (error.name === \"WaspSegmentParsingError\") {         // This error was due to a parsing failure of a segment     } });  WaspSegmentParsingError also may have the following property:   mediaType (string): The “media type” associated to the segment. Examples of media types are \"Audio\" for a segment linked to resources containing just audio media content, and \"Video\" for a segment which contains video content (it may be only video or video with audio).  ","anchorH1":"player_errors","anchorH2":"error_type:_%60waspsegmentparsingerror%60"},{"h1":"Player Errors","h2":"Error type: WaspSegmentParsingError","h3":"Error codes","body":"A WaspSegmentParsingError’s code property can be set to any of the following values:   \"SegmentTransmuxingError\": An error arised when trying to transmux a segment (the action of changing the segment’s container to improve browser compatibility).   \"SegmentParsingOtherError\": An uncategorized error arised when parsing a segment.  ","anchorH1":"player_errors","anchorH2":"error_type:_%60waspsegmentparsingerror%60","anchorH3":"error_codes_(5)"},{"h1":"Player Errors","h2":"Error type: WaspSourceBufferCreationError","body":"WaspSourceBufferCreationError are errors triggered when the WaspHlsPlayer encountered an issue while creating a SourceBuffer, which are media buffers provided by the browser through its “MediaSource Extensions” API. Its name property is set to \"WaspSourceBufferCreationError\": player.addEventlistener(\"error\", (error) => {     if (error.name === \"WaspSourceBufferCreationError\") {         // An error happened when creating a SourceBuffer     } });  WaspSourceBufferCreationError also may have the following property:   mediaType (string): The “media type” associated to that SourceBuffer. Examples of media types are \"Audio\" for a SourceBuffer linked to resources containing just audio media content, and \"Video\" for a SourceBuffer which contains video content (it may be only video or video with audio).  ","anchorH1":"player_errors","anchorH2":"error_type:_%60waspsourcebuffercreationerror%60"},{"h1":"Player Errors","h2":"Error type: WaspSourceBufferCreationError","h3":"Error codes","body":"A WaspSegmentParsingError’s code property can be set to any of the following values:   \"SourceBufferCantPlayType\": The mime type communicated during SourceBuffer creation was not supported.   `“SourceBufferCreationOtherError”: An uncategorized error arised while creating a SourceBuffer.  ","anchorH1":"player_errors","anchorH2":"error_type:_%60waspsourcebuffercreationerror%60","anchorH3":"error_codes_(6)"},{"h1":"Player Errors","h2":"Error type: WaspSourceBufferError","body":"WaspSourceBufferError are errors triggered when the WaspHlsPlayer encountered an issue while doing an operation on a successfully created SourceBuffer, which are media buffers provided by the browser through its “MediaSource Extensions” API. Its name property is set to \"WaspSourceBufferError\": player.addEventlistener(\"error\", (error) => {     if (error.name === \"WaspSourceBufferError\") {         // An error happened when doing an operation on a SourceBuffer     } });  WaspSourceBufferError also may have the following property:   mediaType (string): The “media type” associated to that SourceBuffer. Examples of media types are \"Audio\" for a SourceBuffer linked to resources containing just audio media content, and \"Video\" for a SourceBuffer which contains video content (it may be only video or video with audio).  ","anchorH1":"player_errors","anchorH2":"error_type:_%60waspsourcebuffererror%60"},{"h1":"Player Errors","h2":"Error type: WaspSourceBufferError","h3":"Error codes","body":"A WaspSourceBufferError’s code property can be set to any of the following values:   \"SourceBufferAppendError\": An error arised when pushing a segment to the SourceBuffer. Generally, this happens when the pushed segment is malformed.   \"SourceBufferFullError\": We could not add more data to the SourceBuffer because it is full.   \"SourceBufferRemoveError\": An error arised when removing data from the SourceBuffer.   \"SourceBufferOtherError\": An uncategorized error arised when doing an operation on a SourceBuffer.  ","anchorH1":"player_errors","anchorH2":"error_type:_%60waspsourcebuffererror%60","anchorH3":"error_codes_(7)"},{"h1":"Player Errors","h2":"Error type: WaspOtherError","body":"WaspOtherError are errors that are other, uncategorized errors that didn’t fit other error types. Its name property is set to \"WaspOtherError\": player.addEventlistener(\"error\", (error) => {     if (error.name === \"WaspSourceBufferCreationError\") {         // An uncategorized error happened     } }); ","anchorH1":"player_errors","anchorH2":"error_type:_%60waspothererror%60"},{"h1":"Player Errors","h2":"Error type: WaspOtherError","h3":"Error codes","body":"A WaspSegmentParsingError’s code property can be set to any of the following values:   \"MediaSourceAttachmentError\": An error arised when trying to either create the MediaSource or attempt to attach it to the MediaSource HTMLMediaElement.   \"NoSupportedVariant\": No supported variant was found in the Multivariant Playlist.   \"UnfoundLockedVariant\": The variant locked through the lockVariant API was not found.   \"Unknown\": An unknown error arised.  ","anchorH1":"player_errors","anchorH2":"error_type:_%60waspothererror%60","anchorH3":"error_codes_(8)"}]},{"file":"./API/Audio_Volume_Management.html","index":[{"h1":"Audio Volume Management","body":"","anchorH1":"audio_volume_management"},{"h1":"Audio Volume Management","h2":"Overview","body":"Updating and getting the audio volume is done differently than most other API of the WaspHlsPlayer in that we encourage you to use the browser’s native means to do so by directly updating property from the <video> element you gave to the WaspHlsPlayer on instantiation. For example, to update the audio volume, you can update the video element’s volume property by setting it to a value between 0 - indicating the quietest sound, to 1 indicating the loudest sound: const videoElement = document.getElementsByTagName(\"video\")[0];  // Full volume videoElement.volume = 1;  To explicitely mute or unmute the audio volume, it is also possible to use the muted property, also found on the <video> element. Using that property has the advantage of keeping the volume property to its last set value (for cases where you want to un-mute to the previous value).","anchorH1":"audio_volume_management","anchorH2":"overview"}]},{"file":"./API/Basic_Methods/initialize.html","index":[{"h1":"initialize method","body":"","anchorH1":"%60initialize%60_method"},{"h1":"initialize method","h2":"Description","body":"Initialize the WaspHlsPlayer, see the API documentation page on initialization for more information.","anchorH1":"%60initialize%60_method","anchorH2":"description"},{"h1":"initialize method","h2":"Syntax","body":"// Without an initial bandwidth setup: const initializationPromise = player.initialize({   workerUrl,   wasmUrl, });  // With an initial bandwidth, generally to start playing with an appropriate // quality directly: const initializationPromise = player.initialize({   workerUrl,   wasmUrl,   initialBandwidth, });    arguments:   initObject Object: The properties required for initialization. This object should have the following properties present:   workerUrl (string): URL to the Worker file, that you have hosted.   wasmUrl (string): URL to the WebAssembly file, that you have hosted.   It has one additional optional property:  initialBandwidth (number|undefined): An initial bandwidth estimate, in bits per second, which will be relied on initially when starting to load the first content. If undefined or not set, the WaspHlsPlayer will define its own initial bandwidth, generally of a poor quality (but will be able to provide a better estimate soon enough).      return value:   Promise: Promise resolving when and if the initialization step finished with success. That Promise may also reject in case any of its step failed (such as the fetching of the required resources), in which case the WaspHlsPlayer won’t be able to be used.","anchorH1":"%60initialize%60_method","anchorH2":"syntax"}]},{"file":"./API/Basic_Methods/load.html","index":[{"h1":"load method","body":"","anchorH1":"%60load%60_method"},{"h1":"load method","h2":"Description","body":"Load a content see the API documentation page on loading a content for more information.","anchorH1":"%60load%60_method","anchorH2":"description"},{"h1":"load method","h2":"Syntax","body":"// Without options player.load(url);  // With options player.load(url, {   startingPosition: initialWantedPosition, });    arguments:   url string: Url to the Multivariant Playlist of the content you want to play.   options Object: Optional argument to configure how the content will be loaded. Can contain the following keys:  startType (number|object|undefined): indicate a preferred starting position. See the documentation page on loading a content for more information     ","anchorH1":"%60load%60_method","anchorH2":"syntax"}]},{"file":"./API/Basic_Methods/updateConfig.html","index":[{"h1":"updateConfig method","body":"","anchorH1":"%60updateconfig%60_method"},{"h1":"updateConfig method","h2":"Description","body":"Update some or all of the Configuration Object properties. That method accepts an object which can be a redefinition of the whole configuration object or only a subset by only declaring some of its properties. For example, to only set the segmentMaxRetry configuration to 3, you can write: player.updateConfig({   segmentMaxRetry: 3, });  Note that to ignore some properties, you can also set them to undefined. As such, the following code will also JUST update the segmentMaxRetry configuration to 3. player.updateConfig({   bufferGoal: undefined,   segmentMaxRetry: 3, });  This is possible because no properties of the Configuration Object has undefined as a valid value. Also note that because most of that configuration’s values are actually relied on by code running in a worker, there’s a necessary delay before it actually becomes considered (it doesn’t happen synchronously).","anchorH1":"%60updateconfig%60_method","anchorH2":"description"},{"h1":"updateConfig method","h2":"Syntax","body":"player.updateConfig(configUpdate);    argument:  configUpdate Object: Updates to combine with the previous configuration object. All properties unset or set to undefined will be let as they were before.   ","anchorH1":"%60updateconfig%60_method","anchorH2":"syntax"}]},{"file":"./API/Basic_Methods/getConfig.html","index":[{"h1":"getConfig method","body":"","anchorH1":"%60getconfig%60_method"},{"h1":"getConfig method","h2":"Description","body":"Obtain the last set Configuration Object as a whole.","anchorH1":"%60getconfig%60_method","anchorH2":"description"},{"h1":"getConfig method","h2":"Syntax","body":"const config = player.getConfig();   return value:  Object: Returns the current Configuration Object, taking into consideration all potential updates you’ve done to it since.","anchorH1":"%60getconfig%60_method","anchorH2":"syntax"}]},{"file":"./API/Basic_Methods/getPlayerState.html","index":[{"h1":"getPlayerState method","body":"","anchorH1":"%60getplayerstate%60_method"},{"h1":"getPlayerState method","h2":"Description","body":"Returns a string describing the current “state” of playback. The various values that this state can be set to are:   \"Stopped\": The last content is stopped or no content was ever loaded.   \"Loading\": Set synchronously when the load method is called, to indicate that a new content is being loaded.   \"Loaded\": the last content loaded with load is now ready to play.   \"Error\": the last content loaded with load has been interrupted due to an error. An \"error\" event should also have been triggered. You can also know which error happened by calling the getError method.   You can be directly notified of when this state change by listening to the playerStateChange event.","anchorH1":"%60getplayerstate%60_method","anchorH2":"description"},{"h1":"getPlayerState method","h2":"Syntax","body":"const playerState = player.getPlayerState();   return value:  string: String describing the playback state the player is in.","anchorH1":"%60getplayerstate%60_method","anchorH2":"syntax"}]},{"file":"./API/Basic_Methods/pause.html","index":[{"h1":"pause method","body":"","anchorH1":"%60pause%60_method"},{"h1":"pause method","h2":"Description","body":"Pause the currently-loaded content. Equivalent to a video element’s pause method. pause can only be called when the WaspHlsPlayer instance is in the \"Loaded\" state and thus when a content is currently loaded. Calling it in any other scenario leads to an error being thrown.","anchorH1":"%60pause%60_method","anchorH2":"description"},{"h1":"pause method","h2":"Syntax","body":"player.pause(); ","anchorH1":"%60pause%60_method","anchorH2":"syntax"}]},{"file":"./API/Basic_Methods/resume.html","index":[{"h1":"resume method","body":"","anchorH1":"%60resume%60_method"},{"h1":"resume method","h2":"Description","body":"Un-pause the currently-loaded content. Equivalent to a video element’s play method. resume can only be called when the WaspHlsPlayer instance is in the \"Loaded\" state and thus when a content is currently loaded. Calling it in any other scenario leads to an error being thrown. Note that when initially loaded, the content will be in the paused state. If you want to begin playback, you will thus have to call resume. The returned promise may reject in cases where playing is blocked, such as when “auto-playing” is disabled on the page. You can see this MDN page for more information on why this promise will reject.","anchorH1":"%60resume%60_method","anchorH2":"description"},{"h1":"resume method","h2":"Syntax","body":"const promise = player.resume(); promise.catch((err) => {   console.warn(\"Impossible to play:\", err); });   return value:  Promise: Result of calling play on the media element. That Promise may reject in cases where playing is blocked. You can see this MDN page for more information on why this promise will reject.","anchorH1":"%60resume%60_method","anchorH2":"syntax"}]},{"file":"./API/Basic_Methods/getError.html","index":[{"h1":"getError method","body":"","anchorH1":"%60geterror%60_method"},{"h1":"getError method","h2":"description","body":"If the player is currently in the \"Error\" state, returns the corresponding error object. In any other case, return null.","anchorH1":"%60geterror%60_method","anchorH2":"description"},{"h1":"getError method","h2":"Syntax","body":"const error = player.getError();   return value:  Object|null: Returns the current error object if in the \"Error\" state or null in any other case.","anchorH1":"%60geterror%60_method","anchorH2":"syntax"}]},{"file":"./API/Basic_Methods/stop.html","index":[{"h1":"stop method","body":"","anchorH1":"%60stop%60_method"},{"h1":"stop method","h2":"Description","body":"Requests that the last loaded content stops, thus also stopping playback and emptying buffers. Note that because the WaspHlsPlayer relies on a Worker where most actions actually occur asynchronously, the content will probably not be yet stopped synchronously after this call. You can know when the content is stopped by listening to when the playerStateChange event switches to the \"Stopped\" state.","anchorH1":"%60stop%60_method","anchorH2":"description"},{"h1":"stop method","h2":"Syntax","body":"player.stop(); ","anchorH1":"%60stop%60_method","anchorH2":"syntax"}]},{"file":"./API/Basic_Methods/addEventListener.html","index":[{"h1":"addEventListener method","body":"","anchorH1":"%60addeventlistener%60_method"},{"h1":"addEventListener method","h2":"Description","body":"Add an event listener to trigger a callback as it happens. The callback will have the event payload as a single argument. The WaspHlsPlayer API is heavily event-based. As an example: to know when a content is loaded, the most straightforward way is to add an event listener for the \"playerStateChange\" event. This can be done only through this method. To have the complete list of player events, consult the Player events page. For example, to listen to errors, you could write: player.addEventListener(\"error\", function (err) {   console.log(`The player stopped with an error: ${err.message}`); }); ","anchorH1":"%60addeventlistener%60_method","anchorH2":"description"},{"h1":"addEventListener method","h2":"Syntax","body":"player.addEventListener(event, callback);    arguments:   event string: The wanted event’s name.   callback Function: The callback for the event. The same callback may be used again when calling removeEventListener.    ","anchorH1":"%60addeventlistener%60_method","anchorH2":"syntax"}]},{"file":"./API/Basic_Methods/removeEventListener.html","index":[{"h1":"removeEventListener method","body":"","anchorH1":"%60removeeventlistener%60_method"},{"h1":"removeEventListener method","h2":"Description","body":"Removes an event listener previously registered through the addEventListener method. This also free-up the corresponding ressources. The callback given is optional: if not given, every registered callback to that event will be removed. For example, to add then remove an event listener for the \"playerStateChange\" event, you can write: const onPlayerStateChange = (state) => {   console.log(\"new player state:\", state); }; player.addEventListener(\"playerStateChange\", onPlayerStateChange); player.removeEventListener(\"playerStateChange\", onPlayerStateChange); ","anchorH1":"%60removeeventlistener%60_method","anchorH2":"description"},{"h1":"removeEventListener method","h2":"Syntax","body":"// Remove all callbacks linked to event player.removeEventListener(event);  // Remove specific listener player.removeEventListener(event, callback);    arguments:   event string: The event name.   callback (optional) Function|undefined: The callback given when calling the corresponding addEventListener API.    ","anchorH1":"%60removeeventlistener%60_method","anchorH2":"syntax"}]},{"file":"./API/Basic_Methods/dispose.html","index":[{"h1":"dispose method","body":"","anchorH1":"%60dispose%60_method"},{"h1":"dispose method","h2":"Description","body":"Stop the current content if one and free all resources taken by the WaspHlsPlayer. Note that because the WaspHlsPlayer relies on a Worker where most actions actually occur asynchronously, the content will probably not be yet stopped synchronously after this call.","anchorH1":"%60dispose%60_method","anchorH2":"description"},{"h1":"dispose method","h2":"Syntax","body":"player.dispose(); ","anchorH1":"%60dispose%60_method","anchorH2":"syntax"}]},{"file":"./API/Playback_Information/isPlaying.html","index":[{"h1":"isPlaying method","body":"","anchorH1":"%60isplaying%60_method"},{"h1":"isPlaying method","h2":"Description","body":"Returns true when there’s both:  A content loaded Playback is not paused.  Note that isPlaying returns true even if playback is stalled due to rebuffering (you can check isRebuffering for this). You can also know when playback starts playing by listening to the playing event.","anchorH1":"%60isplaying%60_method","anchorH2":"description"},{"h1":"isPlaying method","h2":"Syntax","body":"const isPlaying = player.isPlaying();   return value:  boolean: Return true if playback is considered as not paused.","anchorH1":"%60isplaying%60_method","anchorH2":"syntax"}]},{"file":"./API/Playback_Information/isPaused.html","index":[{"h1":"isPaused method","body":"","anchorH1":"%60ispaused%60_method"},{"h1":"isPaused method","h2":"Description","body":"Returns true when playback is currently paused. Playback may restart only once a resume call is called:   from the current position if playback was not ended.   from the minimum position if playback was ended.   You can also know when a pause begins by listening to the paused event.","anchorH1":"%60ispaused%60_method","anchorH2":"description"},{"h1":"isPaused method","h2":"Syntax","body":"const isPaused = player.isPaused();   return value:  boolean: Return true if playback is considered paused.","anchorH1":"%60ispaused%60_method","anchorH2":"syntax"}]},{"file":"./API/Playback_Information/isRebuffering.html","index":[{"h1":"isRebuffering method","body":"Returns true when playback is currently not advancing because of rebuffering. You can also know when playback enters or exits a rebuffering period respectively by listening to the rebufferingStarted or the rebufferingEnded events. Rebuffering is a period during which playback is paused to build back buffer, in that condition, playback will only restart (by itself) once enough buffer is loaded. Rebuffering can for example happen if the network bandwidth is currently too low to play sustainably the current content or due to some other event like a seek. Note that rebuffering can also happen when playback is paused. It just means that there’s not enough media data to begin playback.","anchorH1":"%60isrebuffering%60_method"},{"h1":"isRebuffering method","h2":"Syntax","body":"const isRebuffering = player.isRebuffering();   return value:  boolean: Return true if playback is currently on hold due to rebuffering.","anchorH1":"%60isrebuffering%60_method","anchorH2":"syntax"}]},{"file":"./API/Playback_Information/isEnded.html","index":[{"h1":"isEnded method","body":"","anchorH1":"%60isended%60_method"},{"h1":"isEnded method","h2":"Description","body":"Returns true when playback of the current content has ended. This ended status is a situation where playback is paused on the last frame. Calling resume at that point will restart playing the content from its begginning. You can also know when playback ends by listening to the ended event.","anchorH1":"%60isended%60_method","anchorH2":"description"},{"h1":"isEnded method","h2":"Syntax","body":"const isEnded = player.isEnded();   return value:  boolean: Return true if playback is considered ended.","anchorH1":"%60isended%60_method","anchorH2":"syntax"}]},{"file":"./API/Playback_Information/isLive.html","index":[{"h1":"isLive method","body":"","anchorH1":"%60islive%60_method"},{"h1":"isLive method","h2":"Description","body":"Returns true when the currently-loaded content can be considered a “live” content. Returns false either when not playing a live content or when no content is loaded yet. A content is considered as live if at least one of its media playlist:  may continue to have future segments (i.e. no EXT-X-ENDLIST tag) is neither of the VOD nor EVENT playlist type (e.g. no EXT-X-PLAYLIST-TYPE tag)  Written in another way, a live content is a content whose old segments might be removed and for which new segments may be generated in the future. Consequently its “minimum position” and “maximum position” may evolve over time. Note that a content can stop being a live content, e.g. when the live is finished. In that case, isLive will return false. You can be warned when isLive’s value might have changed by listening to the ContentInfoUpdate event. You can also know when it is first set after a load call either by listening to this same ContentInfoUpdate event or by calling isLive when reaching the \"Loaded\" state.","anchorH1":"%60islive%60_method","anchorH2":"description"},{"h1":"isLive method","h2":"Syntax","body":"const isLive = player.isLive();   return value:  boolean: Return true if the current content may be considered a live content.","anchorH1":"%60islive%60_method","anchorH2":"syntax"}]},{"file":"./API/Playback_Information/isVod.html","index":[{"h1":"isVod method","body":"","anchorH1":"%60isvod%60_method"},{"h1":"isVod method","h2":"Description","body":"Returns true when the currently-loaded content can be considered a “VOD” content. Returns false either when not playing a VOD content or when no content is loaded yet. A content is considered as VOD if all of its media playlists have the VOD playlist type. Consequently, a VOD content will never have new segments added or old segments removed, which also means that its “minimum position” and “maximum position” won’t evolve since the content is loaded. Note that a content can start as a non-VOD content but may end as one. You can be warned when isVod’s value might have changed by listening to the ContentInfoUpdate event. You can also know when it is first set after a load call either by listening to this same ContentInfoUpdate event or by calling isLive when reaching the \"Loaded\" state.","anchorH1":"%60isvod%60_method","anchorH2":"description"},{"h1":"isVod method","h2":"Syntax","body":"const isVod = player.isVod();   return value:  boolean: Return true if the current content may be considered a VOD content.","anchorH1":"%60isvod%60_method","anchorH2":"syntax"}]},{"file":"./API/Position_Control/getPosition.html","index":[{"h1":"getPosition method","body":"","anchorH1":"%60getposition%60_method"},{"h1":"getPosition method","h2":"Description","body":"getPosition returns the current playback position in playlist time in seconds. That is, it returns the currently-played position. If a content is loaded, is not paused and not rebuffering, that position should advance roughly at a linear pace, e.g. around one second every seconds if the speed is currently set to 1 (or two seconds per seconds with a speed of 2 and so on) as long as it is not paused, do not rebuffers and do not encounter playback issues. However, some small differences between increases of position and linear time are to be expected (for example, due to various small decoding-related and sometimes performance-related unimportant issues). If no content is currently loaded, getPosition will return 0.","anchorH1":"%60getposition%60_method","anchorH2":"description"},{"h1":"getPosition method","h2":"About “playlist time”","body":"As written above, the returned time is in playlist time in seconds. What I mean by that is that that time is expressed as the time extrapolated from the MediaPlaylist (for example for a live content, it might be the unix timestamp corresponding to the time at which the corresponding media was broadcasted), which might be different from the “media time” actually associated to the HTML media element (such as the currentTime attribute from an HTMLMediaElement). In the WaspHlsPlayer, we always rely on playlist time to facilitate usage of the API. If you wish to convert between media time and playlist time (for example if you want to exploit HTML properties), you may obtain the offset between the two through the getMediaOffset method.","anchorH1":"%60getposition%60_method","anchorH2":"about_%22playlist_time%22"},{"h1":"getPosition method","h2":"Syntax","body":"const position = player.getPosition();   return value:  number: The current playing position, in playlist time in seconds.","anchorH1":"%60getposition%60_method","anchorH2":"syntax"}]},{"file":"./API/Position_Control/seek.html","index":[{"h1":"seek method","body":"","anchorH1":"%60seek%60_method"},{"h1":"seek method","h2":"Description","body":"Change the current playback position, in playlist time in seconds. Calling seek can only be done when the WaspHlsPlayer is in the \"Loaded\" state and thus when a content is currently loaded. Calling it in any other scenario leads to an error being thrown. This is the method you want to call when you want to “move” playback to another position, e.g. when clicking on the “progress bar” displayed in your UI.","anchorH1":"%60seek%60_method","anchorH2":"description"},{"h1":"seek method","h2":"About “playlist time”","body":"As written above, the given time is in playlist time in seconds. What I mean by that is that that time is expressed as the time extrapolated from the MediaPlaylist (for example for a live content, it might be the unix timestamp corresponding to the time at which the corresponding media was broadcasted), which might be different from the “media time” actually associated to the HTML media element (such as the currentTime attribute from an HTMLMediaElement). In the WaspHlsPlayer, we always rely on playlist time to facilitate usage of the API. If you wish to convert between media time and playlist time (for example if you want to exploit HTML properties), you may obtain the offset between the two through the getMediaOffset method.","anchorH1":"%60seek%60_method","anchorH2":"about_%22playlist_time%22"},{"h1":"seek method","h2":"Syntax","body":"player.seek(newPosition);    arguments:  newPosition string: The new position to “seek” to, in playlist time in seconds.   ","anchorH1":"%60seek%60_method","anchorH2":"syntax"}]},{"file":"./API/Position_Control/getMinimumPosition.html","index":[{"h1":"getMinimumPosition method","body":"","anchorH1":"%60getminimumposition%60_method"},{"h1":"getMinimumPosition method","h2":"Description","body":"getMinimumPosition is a method allowing to obtain the minimum playlist position in seconds where playable data is currently available. Basically, it is the first reachable position in the fetched media playlist, or if there’s separate audio and a video Media Playlists, the minimum of that first reachable position between both of them (written another way: the minimum reachable position with both audio and video playable data). Its intended purpose is to indicate to you the range where you may be able to seek in the content (i.e. change the position). If no content is currently loaded, getMinimumPosition will return undefined. Note that this minimum position might evolve over time, depending on the type of content being played. More information on this in this documentation page.","anchorH1":"%60getminimumposition%60_method","anchorH2":"description"},{"h1":"getMinimumPosition method","h2":"About “playlist time”","body":"As written above, the returned time is in playlist time in seconds. What I mean by that is that that time is expressed as the time extrapolated from the MediaPlaylist (for example for a live content, it might be the unix timestamp corresponding to the time at which the corresponding media was broadcasted), which might be different from the “media time” actually associated to the HTML media element (such as the currentTime attribute from an HTMLMediaElement). In the WaspHlsPlayer, we always rely on playlist time to facilitate usage of the API. If you wish to convert between media time and playlist time (for example if you want to exploit HTML properties), you may obtain the offset between the two through the getMediaOffset method.","anchorH1":"%60getminimumposition%60_method","anchorH2":"about_%22playlist_time%22"},{"h1":"getMinimumPosition method","h2":"For live contents and other non-VoD contents","body":"When playing some types of contents such as live contents, the minimum reachable position might increase over time as old data may become progressively unavailable. To be alerted when the minimum position changes, you may want to listen to the contentInfoUpdate event which sends a minimumPosition property reflecting that new minimum position as a payload. It should be noted that in this evoked scenario, the value returned by getMinimumPosition might change, but will only do so gradually, e.g. once one of the Media Playlist is updated. This might be counter-intuitive if for example you expect the minimum position to increase linearly (for example a 1 second increase every seconds) over time. If you want to simulate a linear increase, for example, to simulate a UI progress bar advancing at a regular pace, you’ll have to calculate that linear progression yourself (you may still want to regularly re-synchronize it by getting getMinimumPosition). As a general rule, changes of the minimum position may be expected unless the content is a VoD content. You can know is you’re playing a VoD content by calling the isVod method after reaching the \"Loaded\" state for that content or by reading the isVod property from a contentInfoUpdate event (which is moreover first sent even before the \"Loaded\" state is reached). On live contents, the minimum position increase can generally be approximated as a linear increase (such as 1 second every seconds) until the end of the content. You can know is you’re playing a live content by calling the isLive method after reaching the \"Loaded\" state for that content or by reading the isLive property from the contentInfoUpdate event. Once the live is ended, isLive should return false. Note that a content may also become a VoD once it is finished, at which point the minimum position will be guaranteed to be definitive. To react directly to this eventuality, you may want to listen to the contentInfoUpdate event and read its isVoD property, or call the isVod method.","anchorH1":"%60getminimumposition%60_method","anchorH2":"for_live_contents_and_other_non-vod_contents"},{"h1":"getMinimumPosition method","h2":"Syntax","body":"const minimumPosition = player.getMinimumPosition();   return value:  number|undefined: The minimum position with playable content. in playlist time in seconds. undefined if no content is currently loaded.","anchorH1":"%60getminimumposition%60_method","anchorH2":"syntax"}]},{"file":"./API/Position_Control/getMaximumPosition.html","index":[{"h1":"getMaximumPosition method","body":"","anchorH1":"%60getmaximumposition%60_method"},{"h1":"getMaximumPosition method","h2":"Description","body":"getMaximumPosition is a method allowing to obtain the maximum playlist position in seconds where playable data is currently available. Basically, it is the last reachable position in the fetched media playlist, or if there’s separate audio and a video Media Playlists, the minimum of that last reachable position between both of them (written another way: the maximum reachable position with both audio and video playable data). Its intended purpose is to indicate to you the range where you may be able to seek in the content (i.e. change the position). If no content is currently loaded, getMaximumPosition will return undefined. Note that this minimum position might evolve over time, depdending on the type of content being played. More information on this in this documentation page.","anchorH1":"%60getmaximumposition%60_method","anchorH2":"description"},{"h1":"getMaximumPosition method","h2":"About “playlist time”","body":"As written above, the returned time is in playlist time in seconds. What I mean by that is that that time is expressed as the time extrapolated from the MediaPlaylist (for example for a live content, it might be the unix timestamp corresponding to the time at which the corresponding media was broadcasted), which might be different from the “media time” actually associated to the HTML media element (such as the currentTime attribute from an HTMLMediaElement). In the WaspHlsPlayer, we always rely on playlist time to facilitate usage of the API. If you wish to convert between media time and playlist time (for example if you want to exploit HTML properties), you may obtain the offset between the two through the getMediaOffset method.","anchorH1":"%60getmaximumposition%60_method","anchorH2":"about_%22playlist_time%22"},{"h1":"getMaximumPosition method","h2":"For non-VoD contents","body":"When playing non-VoD contents such as live contents, the maximum reachable position might increase over time as new data may be made available progressively. To be alerted when the maximum position changes, you may want to listen to the contentInfoUpdate event which sends a maximumPosition property reflecting that new maximum position as a payload. It should be noted that in this scenario, the value returned by getMaximumPosition might update, but will only do so gradually, e.g. once one of the Media Playlist is updated. This might be counter-intuitive if for example you expect the maximum position to increase linearly (for example a 1 second increase every seconds) over time. If you want to simulate a linear increase, for example, to simulate a UI progress bar advancing at a regular pace, you’ll have to calculate that linear progression yourself (you may still want to regularly re-synchronize it by getting getMaximumPosition). You can know is you’re playing such type of content by calling the isVod method after reaching the \"Loaded\" state for that content or by reading the isVod property from a contentInfoUpdate event (which is moreover first sent even before the \"Loaded\" state is reached). If it returns false, the maximum position might increase. For live contents for example (you can know if you’re playing a live content by calling the isLive method after reaching the \"Loaded\" state) or by reading the isLive property from ContentInfoUpdate events, the maximum position increase can generally be approximated as a linear increase (such as 1 second every seconds) until the end of the content (at which point isLive will be set to false).","anchorH1":"%60getmaximumposition%60_method","anchorH2":"for_non-vod_contents"},{"h1":"getMaximumPosition method","h2":"For VOD contents","body":"When playing a VOD content, the maximum position will be set before the \"Loaded\" state is reached and won’t evolve as long as that content is loaded. You can know is you’re playing a VOD content by calling the isVod method after reaching the \"Loaded\" state for that content or by reading the isVod property from a contentInfoUpdate event (which is moreover first sent even before the \"Loaded\" state is reached).","anchorH1":"%60getmaximumposition%60_method","anchorH2":"for_vod_contents"},{"h1":"getMaximumPosition method","h2":"Syntax","body":"const maximumPosition = player.getMaximumPosition();   return value:  number|undefined: The maximum position with playable content. in playlist time in seconds. undefined if no content is currently loaded.","anchorH1":"%60getmaximumposition%60_method","anchorH2":"syntax"}]},{"file":"./API/Position_Control/getMediaDuration.html","index":[{"h1":"getMediaDuration method","body":"","anchorH1":"%60getmediaduration%60_method"},{"h1":"getMediaDuration method","h2":"Description","body":"getMediaDuration returns the last estimated position playable in the content once it is fully loaded, in playlist time in seconds. When the position reaches that value, the content will generally end. If that value isn’t currently set because no content is loaded yet, getMediaDuration will return NaN. Under the hood, that method uses the HTML media element’s duration attribute. For content that aren’t yet finished, i.e. contents that are not VoD contents, the duration will generally be set to a very high value as the true latest estimated position is unknown yet. When the content is a VOD content (when the isVod method returns true), the duration will be set as the end of the last segment. Note however that it may slightly evolve even for VOD content when reaching the true` end of the content, as it goes from an estimate to its true precise value.","anchorH1":"%60getmediaduration%60_method","anchorH2":"description"},{"h1":"getMediaDuration method","h2":"About “playlist time”","body":"As written above, the returned time is in playlist time in seconds. What I mean by that is that that time is expressed as the time extrapolated from the MediaPlaylist (for example for a live content, it might be the unix timestamp corresponding to the time at which the corresponding media was broadcasted), which might be different from the “media time” actually associated to the HTML media element (such as the currentTime attribute from an HTMLMediaElement). In the WaspHlsPlayer, we always rely on playlist time to facilitate usage of the API. If you wish to convert between media time and playlist time (for example if you want to exploit HTML properties), you may obtain the offset between the two through the getMediaOffset method.","anchorH1":"%60getmediaduration%60_method","anchorH2":"about_%22playlist_time%22"},{"h1":"getMediaDuration method","h2":"Syntax","body":"const duration = player.getMediaDuration();   return value:  number: The last estimated position playable in the content once fully loaded, in playlist time in seconds. NaN if no content is yet loaded.","anchorH1":"%60getmediaduration%60_method","anchorH2":"syntax"}]},{"file":"./API/Position_Control/getMediaOffset.html","index":[{"h1":"getMediaOffset method","body":"","anchorH1":"%60getmediaoffset%60_method"},{"h1":"getMediaOffset method","h2":"Description","body":"Returns an offset allowing to convert from playlist time to media time and vice-versa. To convert from media time to playlist time you substract the media offset from that media time. To convert from playlist time to media time you add the media offset to the playlist time. If no content is currently loaded, getMediaOffset will return undefined.","anchorH1":"%60getmediaoffset%60_method","anchorH2":"description"},{"h1":"getMediaOffset method","h2":"Playlist time and media time","body":"What I call the “playlist time” here is the time extrapolated from the MediaPlaylist (for example for a live content, it might be the unix timestamp corresponding to the time at which the corresponding media was broadcasted), which might be different from the “media time” actually associated to the HTML media element (such as the currentTime attribute from an HTMLMediaElement). In the WaspHlsPlayer, we always rely on the playlist time to facilitate usage of the API. However on native HTML API, you will generally encounter media time.","anchorH1":"%60getmediaoffset%60_method","anchorH2":"playlist_time_and_media_time"},{"h1":"getMediaOffset method","h2":"Syntax","body":"const mediaOffset = player.getMediaOffset();   return value:  number|undefined: The media offset allowing to convert between playlist and media time. undefined if no content is currently loaded.","anchorH1":"%60getmediaoffset%60_method","anchorH2":"syntax"}]},{"file":"./API/Speed_Control/setSpeed.html","index":[{"h1":"setSpeed method","body":"","anchorH1":"%60setspeed%60_method"},{"h1":"setSpeed method","h2":"Description","body":"Update the speed of playback for the currently-loaded content. The “speed” of playback is the average pace at which the content will be played. A speed of 1 indicates that the WaspHlsPlayer will try to play 10 seconds of media content in 10 seconds, a speed of 2 indicates that it will try to play it in 5 seconds, a speed of 0.5, and that will be 20 seconds and so on. Calling setSpeed can only be done when the WaspHlsPlayer is in the \"Loaded\" state and thus when a content is currently loaded. Calling it in any other scenario leads to an error being thrown. You may know the current speed of playback by calling the getSpeed method, note however that getSpeed may not be up-to-date yet if setSpeed has been called very recently. This is because getSpeed only returns the speed considered by the WaspHlsPlayer’s WebWorker and that WebWorker communication happens asynchronously.","anchorH1":"%60setspeed%60_method","anchorH2":"description"},{"h1":"setSpeed method","h2":"Syntax","body":"player.setSpeed(newSpeed);    arguments:  newSpeed number: The new playback speed to set.   ","anchorH1":"%60setspeed%60_method","anchorH2":"syntax"}]},{"file":"./API/Speed_Control/getSpeed.html","index":[{"h1":"getSpeed method","body":"","anchorH1":"%60getspeed%60_method"},{"h1":"getSpeed method","h2":"Description","body":"Returns the last applied speed of playback on the currently-loaded content, or 1 if no content is currently loaded. The “speed” of playback is the average pace at which the content will be played. A speed of 1 indicates that the WaspHlsPlayer will try to play 10 seconds of media content in 10 seconds, a speed of 2 indicates that it will try to play it in 5 seconds, a speed of 0.5, and that will be 20 seconds and so on. To update the speed of playback you need to call the setSpeed method when a content is loaded (the WaspHlsPlayer is in the \"Loaded\" state). Note however that getSpeed won’t return that new value synchronously after the setSpeed call as the new speed is first processed by the WaspHlsPlayer’s WebWorker, an inherently asynchronous process.","anchorH1":"%60getspeed%60_method","anchorH2":"description"},{"h1":"getSpeed method","h2":"Syntax","body":"const speed = player.getSpeed();   return value:  number: The last applied playback speed on the currently loaded content.","anchorH1":"%60getspeed%60_method","anchorH2":"syntax"}]},{"file":"./API/Variant_Selection/getCurrentVariant.html","index":[{"h1":"getCurrentVariant method","body":"","anchorH1":"%60getcurrentvariant%60_method"},{"h1":"getCurrentVariant method","h2":"Description","body":"Returns the information on the currently considered HLS variant. Returns undefined if unknown or if no content is loaded. A variant in HLS is basically a set of media rendition in a given quality. The WaspHlsPlayer may regularly switch between variant, for example because of changing network conditions unless the current variant has been locked. When set, the returned object has the following properties (same than for a getVariantList call):   id (number): The identifier for that variant. Might be useful for example when wanting to lock that variant in place through the lockVariant method.   width (number | undefined): The optimal width at which the video media data linked to that variant is displayed, in pixel. undefined if unknown or if there’s no video data.   height (number | undefined): The optimal height at which the video media data linked to that variant is displayed, in pixel. undefined if unknown or if there’s no video data.   frameRate (number | undefined): The maximum frame for the video media data linked to that variant. undefined if unknown or if there’s no video data.   bandwidth (number | undefined): The peak segment bit rate of any media combination in that variant, in bits per second. undefined if unknown,   The current variant should be known once the variantUpdate event is sent for the currently-loaded content, which should happen at least once before the content is in the \"Loaded\" state (and thus before playback starts).","anchorH1":"%60getcurrentvariant%60_method","anchorH2":"description"},{"h1":"getCurrentVariant method","h2":"Syntax","body":"const currentVariant = player.getCurrentVariant();   return value:  Object: Characteristics of the currently considered variant (see previous chapter). undefined if no content is loaded or if the current variant is unknown.","anchorH1":"%60getcurrentvariant%60_method","anchorH2":"syntax"}]},{"file":"./API/Variant_Selection/getVariantList.html","index":[{"h1":"getVariantList method","body":"","anchorH1":"%60getvariantlist%60_method"},{"h1":"getVariantList method","h2":"Description","body":"Returns the list of available HLS variants for the currently loaded content. A variant in HLS is basically a set of media rendition in a given quality. The WaspHlsPlayer may regularly switch between variant, for example because of changing network conditions unless the current variant has been locked. This method will returns an array of objects, each object containing the information available for a particular variant. Each of those objects should contain the following keys:   id (number): The identifier for that variant. Might be useful for example when wanting to lock that variant in place through the lockVariant method.   width (number | undefined): The optimal width at which the video media data linked to that variant is displayed, in pixel. undefined if unknown or if there’s no video data.   height (number | undefined): The optimal height at which the video media data linked to that variant is displayed, in pixel. undefined if unknown or if there’s no video data.   frameRate (number | undefined): The maximum frame for the video media data linked to that variant. undefined if unknown or if there’s no video data.   bandwidth (number | undefined): The peak segment bit rate of any media combination in that variant, in bits per second. undefined if unknown,   That list of variants is known once the variantListUpdate event is sent for the currently-loaded content, which should happen at least once before the content is in the \"Loaded\" state (and thus before playback starts). If no content is currently loaded or if there is but variants characteristics are either inexistant or unknown, this method will return an empty array ([]).","anchorH1":"%60getvariantlist%60_method","anchorH2":"description"},{"h1":"getVariantList method","h2":"Syntax","body":"const variants = player.getVariantList();   return value:  Array.<Object>: Characteristics of the currently available variants (see previous chapter). Empty if no content is loaded, if there’s no if variants’ characteristics are unknown.","anchorH1":"%60getvariantlist%60_method","anchorH2":"syntax"}]},{"file":"./API/Variant_Selection/lockVariant.html","index":[{"h1":"lockVariant method","body":"","anchorH1":"%60lockvariant%60_method"},{"h1":"lockVariant method","h2":"Description","body":"“Lock” a specific HLS variant (i.e. quality) to prevent the WaspHlsPlayer from switching from a variant to another due to e.g. changing network conditions This methods takes a number in argument which corresponds to the corresponding variant object’s id property. The main location where you may find those objects are through the getVariantList method and the variantListUpdate event. Once locked, it is possible to unlock the variant for the currently-loaded content by calling the unlockVariant method. lockVariant can only be called when the WaspHlsPlayer instance is in the \"Loaded\" state and thus when a content is currently loaded. Calling it in any other scenario leads to an error being thrown.","anchorH1":"%60lockvariant%60_method","anchorH2":"description"},{"h1":"lockVariant method","h2":"Influence on audio tracks","body":"Locking a variant through lockVariant may also trigger an automatic audio track change previously set through a setAudioTrack call, in which case you will receive the corresponding audioTrackUpdate event. This is because some audio tracks may only be compatible with some variants but not others. It should be noted however that such scenarios are rare and may only be seen in the few HLS contents which enforce such rules.","anchorH1":"%60lockvariant%60_method","anchorH2":"influence_on_audio_tracks"},{"h1":"lockVariant method","h2":"Note about its asynchronicity","body":"As the WaspHlsPlayer relies on a Worker where most actions actually occur asynchronously, the variant will not be locked synchronously after this call. Likewise, calling the getLockedVariant method synchronously after calling lockVariant may not returns the characteristics of the locked variant yet. You will receive a variantLockUpdate event once the variant is known to be actively locked by the WaspHlsPlayer. If the locked variant was actually not found on the content, a \"warning\" event will be triggered with a code set to \"UnfoundLockedVariant\".","anchorH1":"%60lockvariant%60_method","anchorH2":"note_about_its_asynchronicity"},{"h1":"lockVariant method","h2":"Syntax","body":"player.lockVariant(variantId);    arguments:  variantId number: The wanted variant’s id property (see getVariantList method and variantListUpdate event.   ","anchorH1":"%60lockvariant%60_method","anchorH2":"syntax"}]},{"file":"./API/Variant_Selection/unlockVariant.html","index":[{"h1":"unlockVariant method","body":"","anchorH1":"%60unlockvariant%60_method"},{"h1":"unlockVariant method","h2":"Description","body":"“Remove” a variant lock previously set with the lockVariant method. Once this method has been called, the WaspHlsPlayer will go back to choosing the most appropriate variant, e.g. by taking into account network conditions. unlockVariant can only be called when the WaspHlsPlayer instance is in the \"Loaded\" state and thus when a content is currently loaded. Calling it in any other scenario leads to an error being thrown.","anchorH1":"%60unlockvariant%60_method","anchorH2":"description"},{"h1":"unlockVariant method","h2":"Note about its asynchronicity","body":"As the WaspHlsPlayer relies on a Worker where most actions actually occur asynchronously, the variant will not be locked synchronously after this call. Likewise, calling the getLockedVariant method synchronously after calling unlockVariant may not return null yet. You will receive a variantLockUpdate event with a payload set to null once the variant is effectively unlocked.","anchorH1":"%60unlockvariant%60_method","anchorH2":"note_about_its_asynchronicity"},{"h1":"unlockVariant method","h2":"Syntax","body":"player.unlockVariant(); ","anchorH1":"%60unlockvariant%60_method","anchorH2":"syntax"}]},{"file":"./API/Variant_Selection/getLockedVariant.html","index":[{"h1":"getLockedVariant method","body":"","anchorH1":"%60getlockedvariant%60_method"},{"h1":"getLockedVariant method","h2":"Description","body":"Returns the locked HLS variant on the currently-loaded content, or null if either no content is currently loaded or if there is but no variant is currently locked. A variant in HLS is basically a set of media rendition in a given quality. The WaspHlsPlayer may regularly switch between variant, for example because of changing network conditions unless the current variant has been locked. When a variant has been locked, getLockedVariant will return the characteristics of that locked variant. Those characteristics are the same than for most other variant API, namely:   id (number): The identifier for that variant. Might be useful for example when wanting to lock that variant in place through the lockVariant method.   width (number | undefined): The optimal width at which the video media data linked to that variant is displayed, in pixel. undefined if unknown or if there’s no video data.   height (number | undefined): The optimal height at which the video media data linked to that variant is displayed, in pixel. undefined if unknown or if there’s no video data.   frameRate (number | undefined): The maximum frame for the video media data linked to that variant. undefined if unknown or if there’s no video data.   bandwidth (number | undefined): The peak segment bit rate of any media combination in that variant, in bits per second. undefined if unknown,   Note that getLockedVariant won’t return its new value synchronously after a lockVariant call as it is is first processed by the WaspHlsPlayer’s WebWorker, an inherently asynchronous process. If you want to know when and if a locked variant through the lockVariant is actually really being considered, you can listen to the variantLockUpdate event.","anchorH1":"%60getlockedvariant%60_method","anchorH2":"description"},{"h1":"getLockedVariant method","h2":"Syntax","body":"const variant = player.getLockedVariant();   return value:  Object|null: If set, the characteristics of the locked variant. If no variant is currently locked, returns null.","anchorH1":"%60getlockedvariant%60_method","anchorH2":"syntax"}]},{"file":"./API/Audio_Track_Selection/getCurrentAudioTrack.html","index":[{"h1":"getCurrentAudioTrack method","body":"","anchorH1":"%60getcurrentaudiotrack%60_method"},{"h1":"getCurrentAudioTrack method","h2":"Description","body":"Returns the information on the currently loaded audio track. Returns undefined if unknown, if no content is loaded or if the content has no audio track. When set, the returned object has the following properties (same than for a getAudioTrackList call):   id (number): The identifier for that audio track. It is generally useful to for example set the audio track though a setAudioTrack call.   language (string | undefined): The primary language used in this audio track, as a language tag. undefined if unknown or if there’s no language involved.   assocLanguage (string | undefined): A secondary language associated to the audio track, as a language tag. Such language is often used in a different role than the language specified through the language property (e.g., written versus spoken, or a fallback dialect). undefined if unknown or if there’s no language involved.   name (string): Human-readable description of the audio track. If the language property is set, it should generally be in that language.   channels (number | undefined): If set, it is the count of audio channels, indicating the maximum number of independent and simultaneous audio channels present in any media data in that audio track. For example, an AC-3 5.1 Rendition would have a channels attribute set to 6.   The current audio track should be known once the audioTrackUpdate event is sent for the currently-loaded content, which should happen at least once before the content is in the \"Loaded\" state (and thus before playback starts).","anchorH1":"%60getcurrentaudiotrack%60_method","anchorH2":"description"},{"h1":"getCurrentAudioTrack method","h2":"Syntax","body":"const currentAudioTrack = player.getCurrentAudioTrack();   return value:  Object: Characteristics of the currently loaded audio track (see previous chapter). undefined if no content is loaded, if there’s no audio tracks in the loaded content or if its characteristics are unknown.","anchorH1":"%60getcurrentaudiotrack%60_method","anchorH2":"syntax"}]},{"file":"./API/Audio_Track_Selection/getAudioTrackList.html","index":[{"h1":"getAudioTrackList method","body":"","anchorH1":"%60getaudiotracklist%60_method"},{"h1":"getAudioTrackList method","h2":"Description","body":"Returns the list of available “audio tracks” for the currently loaded content. Audio tracks are one or multiple renditions (e.g. when there’s multiple audio qualities) associated to a given set of characteristics: a language, accessibility concepts etc… This method will returns an array of objects, each object containing the information available for a particular audio track. Each of those objects should contain the following keys (same than for the audioTrackListUpdate event):   id (number): The identifier for that audio track. It is generally useful to for example set the audio track though a setAudioTrack call.   language (string | undefined): The primary language used in this audio track, as a language tag. undefined if unknown or if there’s no language involved.   assocLanguage (string | undefined): A secondary language associated to the audio track, as a language tag. Such language is often used in a different role than the language specified through the language property (e.g., written versus spoken, or a fallback dialect). undefined if unknown or if there’s no language involved.   name (string): Human-readable description of the audio track. If the language property is set, it should generally be in that language.   channels (number | undefined): If set, it is the count of audio channels, indicating the maximum number of independent and simultaneous audio channels present in any media data in that audio track. For example, an AC-3 5.1 Rendition would have a channels attribute set to 6.   That list of audio tracks is known once the audioTrackListUpdate event is sent for the currently-loaded content, which should happen at least once before the content is in the \"Loaded\" state (and thus before playback starts). If no content is currently loaded or if there is but audio tracks characteristics are either inexistant or unknown, this method will return an empty array ([]).","anchorH1":"%60getaudiotracklist%60_method","anchorH2":"description"},{"h1":"getAudioTrackList method","h2":"Syntax","body":"const audioTracks = player.getAudioTrackList();   return value:  Array.<Object>: Characteristics of the currently available audio tracks (see previous chapter). Empty if no content is loaded, if there’s no audio tracks in the loaded content or if its characteristics are unknown.","anchorH1":"%60getaudiotracklist%60_method","anchorH2":"syntax"}]},{"file":"./API/Audio_Track_Selection/setAudioTrack.html","index":[{"h1":"setAudioTrack method","body":"","anchorH1":"%60setaudiotrack%60_method"},{"h1":"setAudioTrack method","h2":"Description","body":"Change the currently-loaded audio track (e.g. change the audio language, switch to an audio track describing what’s happening on the screen, switch to an audio track relying on more channels and so on.). This methods takes a number in argument which corresponds to the corresponding track object’s id property. The main location where you may find those objects are through the getAudioTrackList method and the audioTrackListUpdate event. You can also set the argument to null to let the WaspHlsPlayer set a default audio track. setAudioTrack can only be called when the WaspHlsPlayer instance is in the \"Loaded\" state and thus when a content is currently loaded. Calling it in any other scenario leads to an error being thrown.","anchorH1":"%60setaudiotrack%60_method","anchorH2":"description"},{"h1":"setAudioTrack method","h2":"Influence on variants","body":"Changing the audio track may also trigger an automatic “unlocking” of a variant previously locked through a lockVariant call, in which case you will receive the corresponding variantLockUpdate event. This is because some audio tracks may only be compatible with some variants but not others. It should be noted however that such scenarios are rare and may only be seen in the few HLS contents which enforce such rules.","anchorH1":"%60setaudiotrack%60_method","anchorH2":"influence_on_variants"},{"h1":"setAudioTrack method","h2":"Note about its asynchronicity","body":"As the WaspHlsPlayer relies on a Worker where most actions actually occur asynchronously, the audio track will not be updated synchronously after this call. Likewise, calling the getCurrentAudioTrack method synchronously after calling setAudioTrack may not returns the characteristics of the set audio track yet. You will receive a audioTrackUpdate event once the audio track is known to be actively loaded by the WaspHlsPlayer.","anchorH1":"%60setaudiotrack%60_method","anchorH2":"note_about_its_asynchronicity"},{"h1":"setAudioTrack method","h2":"Syntax","body":"player.setAudioTrack(trackId);    arguments:   trackId number|null: The wanted track’s id property (see getAudioTrackList method and audioTrackListUpdate event. Can be set to null to let the WaspHlsPlayer set a default one instead.    ","anchorH1":"%60setaudiotrack%60_method","anchorH2":"syntax"}]}]